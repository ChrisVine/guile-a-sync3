@node thread pool,monotonic time,await ports,Top

This (a-sync thread-pool) module supplements the @ref{event
loop,,(a-sync event-loop)} module.  (a-sync event-loop) provides
asynchronous procedures which can wait on the completion of a task
running in a worker thread or on an event loop running in another
thread.  However, sometimes it is better to run tasks in a thread pool
rather than launching worker threads, particularly where the workload
suits having the number of threads in the thread pool approximating to
the number of local processors available to the program.  (In guile,
the number of processors so available can be obtained using the
current-processor-count procedure.)

This (a-sync thread-pool) module provides such a thread pool, together
with two asynchronous procedures (await-task-in-thread-pool! and
await-generator-in-thread-pool!) which can wait in an event loop for a
task on the thread pool to complete and provide its result.

The thread pool objects provided by this module do not make provision
for rate limiting similar to that provided by the event loops in the
@ref{event loop,,(a-sync event-loop)} module.  This is because there
is no one-size-fits-all way of doing so.  One common approach is, as
in the case of the event loops provided by this library, to apply
throttling to threads which add tasks by enforcing a wait in their
thread of execution when the level of queued tasks reaches too high a
level, so hindering their ability to add new ones.  However this is
counter productive where it is a task running on the thread pool which
is adding the new tasks, particularly with a thread pool having only a
few threads running in its pool.  Another approach is to throw an
exception when adding tasks which exceed a user-selectable level.

The best approach is for user code to provide its own rate limiting in
cases where the way that that code is organised means that it could
produce an excessive number of accumulating unexecuted tasks in the
thread pool, possibly by applying delays when unexecuted tasks rise in
number excessively, using timeouts with an event loop. This may be
checked for by having code call the thread-pool-get-num-tasks
procedure before adding a significant batch of new tasks in order to
test queue size, and if necessary postpone adding the new tasks until
the size of the already accumulated tasks has reduced.

This module provides the following procedures:

@deffn {Scheme Procedure} make-thread-pool #:key max-threads min-threads idle non-blocking
This procedure constructs a thread pool object.  It takes four
optional arguments.  The #:max-thread keyname specifies the maximum
number of threads which will run in the pool, and the default value is
8.  The #:min-threads keyname specifies the minimum number of
persistent threads which will run in the pool and will not be subject
to an #:idle timeout, and the default value is 0.  It is an error if
#:min-threads is greater than #:max-threads.

The #:idle keyname specifies the length of time in milliseconds that
threads greater in number than #:min-threads and not executing any
tasks will remain in existence.  The default is 10000 (10 seconds).

The #:non-blocking keyname affects the operation of the
thread-pool-stop! procedure.  When set to #f, which is the default,
that procedure will not return until all tasks previously added to the
pool have completed.  If set to #t, the thread-pool-stop! procedure
will return immediately, before all tasks have finished.

The #:max-threads, #:non-blocking and #:idle settings may subsequently
be altered by applying the thread-pool-change-max-threads!,
thread-pool-set-non-blocking! or thread-pool-set-idle-time! procedure
to the pool.

This procedure will throw an exception if the system is unable to
start the number of threads given as the #:min-threads argument.  In
such a case, any threads which have in fact started in the pool will
be killed.

This procedure is first available in version 0.12 of this library.
@end deffn

@deffn {Scheme Procedure} thread-pool? obj
This procedure indicates whether 'obj' is a thread pool object
constructed by make-thread-pool.

This procedure is first available in version 0.12 of this library.
@end deffn

@deffn {Scheme Procedure} thread-pool-get-num-tasks pool
This procedure returns the number of tasks which the thread pool
object is at present either running in the pool or has queued for
execution.  This procedure will not throw.  It is also thread safe,
although it accesses the task number field outside the pool mutex and
therefore with relaxed memory ordering.  That enables this procedure
to be applied more efficiently for rate limiting purposes but the
result might at any one time be marginally out of date.

This procedure is first available in version 0.12 of this library.
@end deffn

@deffn {Scheme Procedure} thread-pool-get-max-threads pool
This procedure returns the current maximum number of threads set for
the thread pool.

This procedure is thread safe (any thread may call it).

This procedure is first available in version 0.12 of this library.
@end deffn

@deffn {Scheme Procedure} thread-pool-change-max-threads! pool delta
This procedure will increase, or if 'delta' is negative reduce, the
maximum number of threads which the thread pool object will currently
run by the value of 'delta'.  The main purpose of this is to enable a
task to increment the maximum thread number where it is about to enter
a call which may block for some time, with a view to decrementing it
later when it has finished making blocking calls, so as to enable
another thread to keep a core active.  If 'delta' is negative and
results in a max_threads value of less than the current number of
running threads, the number of threads actually running will only be
reduced as tasks complete, or as idle timeouts expire.  This procedure
does nothing if thread-pool-stop! has previously been called.  This
procedure is thread safe - any thread may call it.

If 'delta' is positive and tasks are currently queued for execution, a
new thread or threads will be started for the queued tasks.  This
procedure may therefore throw an exception if the system is unable to
start the required new thread(s).

This procedure is first available in version 0.12 of this library.
@end deffn

@deffn {Scheme Procedure} thread-pool-get-non-blocking pool
This procedure returns the current non-blocking status of the thread
pool.  (See the documentation on the thread-pool-stop!  procedure for
more information about what that means.)

This procedure is thread safe (any thread may call it).

This procedure is first available in version 0.12 of this library.
@end deffn

@deffn {Scheme Procedure} thread-pool-set-non-blocking! pool val
This procedure sets the non-blocking status of the thread pool.  (See
the documentation on the thread-pool-stop!  procedure for more
information about what that means.)

This procedure is thread safe (any thread may call it).

This procedure is first available in version 0.12 of this library.
@end deffn

@deffn {Scheme Procedure} thread-pool-get-idle-time pool
This procedure returns the current idle time setting for the thread
pool, in milliseconds.

This procedure is thread safe (any thread may call it).

This procedure is first available in version 0.12 of this library.
@end deffn

@deffn {Scheme Procedure} thread-pool-set-idle-time! pool millisecs
This procedure sets the current idle time for the thread pool, namely
the length of time in milliseconds that threads greater in number than
the minimum and not executing any tasks will remain in existence
waiting for new tasks.  This will only have effect for threads in the
pool which begin waiting for new tasks after this procedure is called.

This procedure is thread safe (any thread may call it).

This procedure is first available in version 0.12 of this library.
@end deffn

@deffn {Scheme Procedure} thread-pool-stop! pool
This procedure will cause the thread-pool object to stop running
tasks.  However, all tasks already running or queued for execution
will be permitted to execute and complete normally.  If the
thread-pool's non-blocking setting is set to #f, this procedure will
wait until all the tasks still to execute have finished before
returning, and if #t it will return straight away.

After this procedure has been called, any attempt to add further tasks
with the thread-pool-add! procedure will fail, and that procedure will
throw a 'thread-pool-error exception.

This procedure is thread safe (any thread may call it) unless the
non-blocking setting is #f, in which case no task running on the
thread-pool object may call this procedure.

This procedure is first available in version 0.12 of this library.
@end deffn

@deffn {Scheme Procedure} thread-pool-add! pool task [fail-handler]
This procedure adds a new task to the thread pool.  If one or more
threads in the pool are currently blocking and waiting for a task,
then the task will begin executing immediately in one of the threads.
If not, and the the number of threads running in the pool is less than
the value returned by thread-pool-get-max-threads, a new thread will
start and the task will execute immediately in the new thread.
Otherwise, the task will be queued for execution as soon as a thread
becomes available. Tasks will be executed in the order in which they
are added to the thread pool object.  This procedure is thread safe
(any thread may call it, including any task running on the thread pool
object).

A task may terminate itself prematurely by throwing an 'exit
exception.  An optional handler procedure may be passed to
'fail-handler' which will be invoked if the task throws an exception,
including an 'exit exception.  If a task throws an exception other
than an 'exit exception and no handler procedure is provided, the
program will terminate.  The 'fail-handler' procedure will be passed
an 'exit symbol if an 'exit exception is thrown; otherwise it will be
passed the same arguments as if it were a guile catch handler.

If this procedure starts a new thread (see above), it may throw an
exception if the system is unable to start the thread correctly.  This
procedure will throw a 'thread-pool-error exception if it is invoked
after the thread pool object concerned has been closed by a call to
thread-pool-stop!.

This procedure is first available in version 0.12 of this library.
@end deffn

@deffn {Scheme Procedure} await-task-in-thread-pool! await resume [loop] pool thunk [handler]
The 'loop' argument is optional.  The procedure will run 'thunk' in
the thread pool specified by the 'pool' argument.  The result of
executing 'thunk' will then be posted to the event loop specified by
the 'loop' argument, or to the default event loop if no 'loop'
argument is provided or if #f is provided as the 'loop' argument
(pattern matching is used to detect the type of the third argument),
and will comprise this procedure's return value.  This procedure is
intended to be called within a waitable procedure invoked by a-sync
(which supplies the 'await' and 'resume' arguments).  It will normally
be necessary to call event-loop-block! on 'loop' (or on the default
event loop) before invoking this procedure.

If the optional 'handler' argument is provided, then that handler will
run if 'thunk' throws, and the return value of the handler would
become the return value of this procedure; otherwise the program will
terminate if an unhandled exception (other than an 'exit exception)
propagates out of 'thunk'.  Note that unlike a handler passed to the
thread-pool-add! procedure, 'handler' will run in the event loop
thread and not in a thread pool thread.  'handler' will also execute
if 'thunk' throws an 'exit exception in order to terminate the task
(see the documentation for the thread-pool-add! procedure for further
information about that exception).  Exceptions thrown by the handler
procedure will propagate out of event-loop-run! for the 'loop' event
loop.

This procedure calls 'await' and must (like the a-sync procedure) be
called in the same thread as that in which the 'loop' or default event
loop runs (as the case may be).

This procedure calls event-post! in the 'loop' event loop, which could
be subject to throttling (see the documentation for the
make-event-loop procedure for further information).

Exceptions may propagate out of this procedure if they arise while
setting up, which shouldn't happen unless the thread pool given by the
'pool' argument has been closed (in which case a 'thread-pool-error
exception will arise), the thread pool tries to start an additional
native thread which the operating system fails to supply (which would
cause a system exception to arise) or memory is exhausted.

Here is an example of the use of await-task-in-thread-pool!:
@example
(set-default-event-loop!) ;; if none has yet been set
(let ((pool (make-thread-pool #:max-threads 4)))
  (a-sync (lambda (await resume)
	    (simple-format #t "1 + 1 is ~A\n"
			   (await-task-in-thread-pool! await resume
						       pool
						       (lambda ()
							 (+ 1 1))))
	    (event-loop-quit!))))
(event-loop-block! #t) ;; because the task runs in another thread
(event-loop-run!)
@end example
This procedure is first available in version 0.12 of this library.
@end deffn

@deffn {Scheme Procedure} await-generator-in-thread-pool! await resume [loop] pool generator proc [handler]
The loop argument is optional.  The 'generator' argument is a
procedure taking one argument, namely a yield argument (see the
documentation on the make-iterator procedure for further details).
This await-generator-in-pool procedure will cause 'generator' to run
as a task in the 'pool' thread pool, and whenever 'generator' yields a
value this will cause 'proc' to execute in the event loop specified by
the 'loop' argument, or in the default event loop if no 'loop'
argument is provided or if #f is provided as the 'loop' argument.
'proc' should be a procedure taking a single argument, namely the
value yielded by the generator.

This procedure is intended to be called within a waitable procedure
invoked by a-sync (which supplies the 'await' and 'resume' arguments).
It will normally be necessary to call event-loop-block! on 'loop' (or
on the default event loop) before invoking this procedure.

If the optional 'handler' argument is provided, then that handler will
run if 'generator' throws an exception; otherwise the program will
terminate if an unhandled exception (other than an 'exit exception)
propagates out of 'generator'.  Note that unlike a handler passed to
the thread-pool-add! procedure, 'handler' will run in the event loop
thread and not in a thread pool thread.  'handler' will also execute
if 'generator' throws an 'exit exception in order to terminate itself
(see the documentation for the thread-pool-add! procedure for further
information about that exception).  This procedure will return #f if
the generator completes normally, or 'guile-a-sync-thread-error if the
generator throws an exception and 'handler' is run (the
'guile-a-sync-thread-error symbol is reserved to the implementation
and should not be yielded by the generator).  Exceptions thrown by the
handler procedure will propagate out of event-loop-run! for the 'loop'
event loop.

This procedure calls 'await' and will return when the generator has
finished or, if 'handler' is provided, upon the generator raising an
exception.  This procedure must (like the a-sync procedure) be called
in the same thread as that in which the 'loop' or default event loop
runs (as the case may be).

This procedure calls event-post! in both the 'loop' event loop, which
could be subject to throttling (see the documentation for the
make-event-loop procedure for further information).

Exceptions may propagate out of this procedure if they arise while
setting up, which shouldn't happen unless the thread loop given by the
'pool' argument has been closed (in which case an 'thread-pool-error
exception will arise), the thread pool tries to start an additional
native thread which the operating system fails to supply (which would
cause a system exception to arise) or memory is exhausted.  Exceptions
arising during the execution of 'proc', if not caught locally, will
propagate out of event-loop-run! for 'loop' or the default event loop
(as the case may be).

Here is an example of the use of await-generator-in-thread-pool!:
@example
(set-default-event-loop!) ;; if none has yet been set
(let ((pool (make-thread-pool #:max-threads 4)))
  (a-sync (lambda (await resume)
	    (await-generator-in-thread-pool! await resume
					     pool
					     (lambda (yield)
					       (let loop ((count 0))
						 (when (< count 5)
						   (yield (* 2 count))
						   (loop (1+ count)))))
					     (lambda (val)
					       (display val)
					       (newline)))
	    (event-loop-block! #f))))
(event-loop-block! #t) ;; because the generator runs in another thread
(event-loop-run!)
@end example
This procedure is first available in version 0.12 of this library.
@end deffn
