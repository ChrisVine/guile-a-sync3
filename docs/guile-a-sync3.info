This is guile-a-sync3.info, produced by makeinfo version 6.7 from
guile-a-sync3.texi.


File: guile-a-sync3.info,  Node: Top,  Next: overview,  Up: (dir)

guile-a-sync3 reference
***********************

This is the guile-a-sync3 library.  It provides both an asynchronous
event loop for guile-3.0, and coroutines to enable an event loop
(including other event loops such as the glib event loop) to be used
with 'await' semantics to deal with inversion of control - otherwise
known as "callback hell".

* Menu:

General overview
* overview::       General overview of the operation of the library

Modules
* coroutines::     (a-sync coroutines) module - provides coroutines for await semantics on asynchronous events
* event loop::     (a-sync event-loop) module - provides an event loop for asynchronous events
* await ports::    (a-sync await-ports) module - provides procedures for suspendable ports
* thread pool::    (a-sync thread-pool) module - provides a thread pool with asychonous procedures
* monotonic time:: (a-sync monotonic-time) module - enables monotonic time to be used for timeouts
* gnome glib::     (a-sync gnome-glib) module - provides some convenience await procedures for the glib main loop using guile-gnome
* compose::        (a-sync compose) module - provides the compose-a-sync macro interface for the a-sync coroutine
* meeting::        (a-sync meeting) module - provides for synchronization between a-sync or compose-a-sync blocks
* g-golf::         provides some convenience await procedures for the glib main loop using g-golf


File: guile-a-sync3.info,  Node: overview,  Next: coroutines,  Prev: Top

*An overview of asynchronous programming with coroutines*

   Asynchronous programming using coroutines might mitigate "callback
hell", but it can still be troublesome to think about.  It can help to
compare it to threads.

   Each 'a-sync' block (see *note (a-sync coroutines): coroutines.) or
'compose-a-sync' block (see *note (a-sync compose): compose.) is a
separate unit of computation, which appears within itself to proceed
sequentially even though in fact it executes asynchronously on an event
loop.  Each such block also appears to execute concurrently with other
'a-sync' or 'compose-a-sync' blocks running on the same event loop.
Each 'a-sync' or 'compose-a-sync' block is therefore in some sense
analogous to a thread of execution.

   If the event loop provided by the *note (a-sync event-loop): event
loop. module is in use, the mechanism by which these "pseudo-threads"
execute on the event loop is by a call to event-loop-run!.
event-loop-run!  therefore behaves in a way which is in some sense
analogous to a scheduler, although multi-plexing is co-operative and/or
i/o event based rather than pre-emptive.

   event-loop-run!  also performs the equivalent of a join operation on
these "pseudo-threads" running on the event loop in question, because by
default it returns when there are no further events to be dealt with
(that is, when all "pseudo-threads" have completed).  So given the
following code, the sum of 1 and 1 will only be printed when both the
timeout has expired and the calculation has been made, both of which
will run as if concurrently (the summing will complete before the
timeout expires):

     (let ((loop (make-event-loop))
           (ret #f))
       (a-sync (lambda (await resume)
     	    (await-timeout! await resume loop
     			    100
     			    (lambda () #f))))
       (a-sync (lambda (await resume)
     	    (set! ret
     		  (await-task! await resume loop
     			       (lambda ()
     				 (+ 1 1))))))
       (event-loop-run! loop)
       (display ret)(newline))

   "Pseudo-threads" (that is 'a-sync' or 'compose-a-sync' blocks)
running on the same event loop can intercommunicate by holding meetings
to exchange a datum (see *note (a-sync meeting): meeting.).  A somewhat
similar result can also be achieved using generators (see the
await-generator!  procedure in the *note (a-sync event-loop): event
loop. module).

   One interesting feature of these "pseudo-threads" is that where one
'a-sync' or 'compose-a-sync' block is waiting on a read or write watch
(including in the await-get*, await-put*, await-connect!  or
await-accept!  procedures), another a-sync block running on the same
event loop can cause execution of the waiting block to come to an end by
removing the watch using event-loop-remove-read-watch!  or
event-loop-remove-write-watch!, as the case may be (and another native
OS thread can do this by posting an event to the event loop which does
the same).

   Apart from these "pseudo-threads", true parallelism is possible using
native OS threads, with the await-task-in-thread!,
await-task-in-event-loop!, await-task-in-thread-pool!,
await-generator-in-thread!, await-generator-in-event-loop!  and
await-generator-in-thread-pool!  procedures.


File: guile-a-sync3.info,  Node: coroutines,  Next: event loop,  Prev: overview,  Up: Top

The (a-sync coroutines) module provides the following procedures:

 -- Scheme Procedure: make-iterator proc . args
     This procedure takes a generator procedure, namely a procedure
     which has a 'yield' parameter for its first or only argument,
     followed by such other arguments (other than the one for the
     'yield' parameter) as the generator procedure requires, and
     constructs an iterator from them.  When the iterator (which
     optionally takes no or one argument) is invoked, it will begin
     executing the procedure unless and until the argument comprising
     the yield procedure is called, which will cause the iterator to
     suspend computation and instead return the value passed to yield,
     if any (yield is a procedure taking no or one argument).  If
     invoked again, the iterator will resume computation at the point
     where it last left off (the yield procedure returning the value, if
     any, passed to the iterator on resuming), following which yield may
     be applied again, and so on.  When the generator procedure has
     executed to the end, the iterator returns 'stop-iteration.  This
     procedure has some resemblance to call/ec, except that (i) instead
     of executing the passed procedure immediately, it returns an
     iterator which will do so, (ii) it is resumable, and (iii) the
     procedure to be executed can receive starting arguments in addition
     to the yield/break argument, to provide an alternative to binding
     them with a lambda closure.  It is similar to ECMAScript generators
     and python generators.

 -- Scheme Procedure: make-coroutine proc . args
     This procedure takes a generator procedure, namely a procedure
     which has a 'yield' parameter for its first or only argument,
     followed by such other arguments (other than the one for the
     'yield' parameter) as the generator procedure requires, and
     constructs a coroutine.  It is similar to make-iterator, in that it
     takes a generator procedure and returns a lambda object (a
     coroutine) which when called will begin executing the generator
     procedure unless and until the argument comprising the yield
     procedure is called, which will cause computation to be suspended.
     However unlike make-iterator, the resumption continuation generated
     on yielding is returned by the coroutine when yielding rather than
     being stored internally in an iterator, so there is no explicit
     retained mutable state.  The return value of the coroutine
     comprises two values: first the resumption continuation, and second
     the value (if any) passed to 'yield' when called.  If the returned
     resumption continuation is subsequently called again, computation
     will be resumed at the point where it last left off (the yield
     procedure returning the value, if any, passed to the continuation
     on resuming) until it completes or it again calls the yield
     procedure.

     Upon the generator procedure finally completing, the value to which
     it evaluates is returned by the resumption continuation together
     with a continuation value of #f.  This differs from the behaviour
     of make-iterator, which returns 'stop-iteration when the generator
     procedure finishes to completion and ignores its return value.

 -- Scheme Procedure: a-sync waitable . args
     a-sync takes a waitable procedure (namely a procedure which takes
     'await' as its first parameter, which is a yield procedure obtained
     by a call to make-iterator, and 'resume' as its second parameter,
     which is an iterator constructed by make-iterator), followed by
     such other arguments (if any) as the waitable procedure requires to
     be passed on to it.  The 'resume' argument must only be called by
     an asynchronous callback, and the 'await' argument must only be
     called by the waitable procedure in order to block until the
     callback is ready to let it resume.  When it unblocks, the 'await'
     argument returns the value (if any) passed to 'resume' by the
     callback.  This async procedure must be called in the same thread
     as that in which the event loop runs (as must 'await' and
     'resume').

     None of the code in the waitable procedure should block on other
     things in the program, except by calls to await (which do not in
     fact block, even though they appear to do so).

     The way it works is that the call to a-sync will begin executing
     the waitable procedure and will return as soon as the first (or
     only) call to 'await' is made by that procedure, or as soon as the
     waitable procedure returns if it makes no calls to 'await'.  Any
     subsequent resumptions of the waitable procedure will take place in
     the event loop concerned as delimited continuations, via the calls
     to 'resume' made by the callbacks.  The effect of the waitable
     procedure subsequently ending, or of further calls to 'await' being
     made within the same waitable procedure, is to return control to
     the event loop by recommencing execution at the point where the
     most recent previous call to 'resume' was made by the last callback
     to execute.

     An exception thrown in a waitable procedure before the first call
     to 'await' to be made by it which is not handled locally will
     propagate out of the a-sync procedure where it may be caught
     normally.  However, if so caught but a callback established by the
     same waitable procedure call still runs and invokes 'resume', the
     waitable procedure will begin running again in the callback.  If
     the same exception is thrown again in consequence, it will
     propagate out of 'resume' in that callback, and then out of the
     event loop - if the event loop in the event-loop module is used,
     this means that it will propagate out of the call to
     event-loop-run!.  It is therefore best if such exceptions are
     handled locally within the waitable procedure.  Any exception
     thrown in the waitable procedure after the first call to 'await'
     which is not handled locally will propagate into the previously
     called callback at the point where 'resume' was last called.  If
     this is handled in the callback, then control will be returned to
     the event loop and the remainder of the waitable procedure will not
     execute.  If that exception is not handled locally in the callback,
     or if the callback throws an exception of its own, then it will
     propagate out of the event loop - if the event loop in the
     event-loop module is used, this means that it will propagate out of
     the call to event-loop-run!.  If an exception propagates out of
     event-loop-run!  for that or some other reason, then the event loop
     will be left in a valid state and it will be as if event-loop-quit!
     had been called on it, but it is then up to the user to catch that
     exception once it is out of event-loop-run!  if she does not want
     the program to terminate.

     After the call to 'resume', the callback should normally just
     return (with a #t or #f value in the case of a file watch or a
     timeout on an event-loop object from the event loop module).  If
     a-sync is used with a file watch or timeout on an event-loop object
     constructed by make-event-loop, the watch callback or timeout
     callback should normally, when the call to 'resume' returns, either
     always return #f (so the callback only fires once) or always return
     #t (so it is responsibility of the waitable procedure to terminate
     the watch or timeout repetitions).  That way, there can never be a
     case where the callback has been removed from the event loop by
     returning false but the waitable procedure still thinks it has a
     call to 'await' to be made.  The *note (a-sync event-loop): event
     loop. module has await-task!, await-task-in-thread!,
     await-task-in-event-loop!, await-yield!, await-generator!,
     await-generator-in-thread!, await-generator-in-event-loop!,
     await-timeout!  and await-sleep!  convenience procedures, the *note
     (a-sync await-ports): await ports. module has
     await-read-suspendable!, await-write-suspendable!, await-getline!,
     await-geteveryline!, await-getsomelines!, await-getblock!,
     await-geteveryblock!, await-getsomeblocks!, await-put-bytevector!
     and await-put-string!  procedures, and the *note (a-sync
     thread-pool): thread pool. module has await-task-in-thread-pool!
     and await-generator-in-thread-pool!  procedures, which will
     correctly set this up for you automatically.  If those convenience
     procedures are used, exceptions should always be handled locally in
     the waitable procedure (and if the callback might throw, in the
     callback also) if it is undesirable that uncaught exceptions
     propagate out of event-loop-run!.  In the case of
     await-task-in-thread!, await-task-in-thread-pool!,
     await-generator-in-thread!  and await-generator-in-thread-pool!,
     those procedures also take an optional handler argument which will
     handle any exceptions thrown by the task or generator: otherwise a
     throwing thread would terminate the program if not caught.

     There can be as many calls to 'await' and asynchronous callbacks in
     any one waitable procedure as wanted, to enable composition of
     asynchronous operations.  However, you cannot run two or more
     asynchronous tasks at the same time with the same await-resume pair
     without an intervening call to await except by doing extra work,
     because the first call to 'await' will match the first callback
     which happens to call 'resume', and so on.  In such cases, 'resume'
     would need to return something like a key-value pair so that the
     result can be correctly identified.  Accordingly this practice is
     discouraged.  Instead, when composing asynchronous tasks within any
     one waitable procedure, operate on a 'start-task -> await-on-result
     -> start-task -> await-on-result ...'  basis, and make calls to
     a-sync on separate waitable procedures for tasks which are to run
     independently (as soon as any code calls a-sync's 'await' procedure
     in any a-sync block, a-sync will return and whatever follows it
     will begin executing, including any following a-sync block).  The
     convenience procedures mentioned above make this easy for many use
     cases (see the examples below).  A waitable procedure can itself
     call a-sync to construct another await-resume pair for the purpose
     of starting other asynchronous events.

     So, don't do this:

          (set-default-event-loop!) ;; if none has yet been set
          (a-sync (lambda (await resume)

          	  (timeout-post! 100
          			 (lambda ()
          			   (resume "expired")
          			   #f))
          	  (event-post! (lambda ()
          			 (resume (+ 1 1))))

          	  (simple-format #t "Timeout ~A\n" (await))
          	  (simple-format #t "1 + 1 is ~A\n" (await))))
          (event-loop-run!)

     Instead do this, where the two asynchronous operations are to run
     consecutively:

          (set-default-event-loop!) ;; if none has yet been set
          (a-sync (lambda (await resume)

          	  (timeout-post! 100
          			 (lambda ()
          			   (resume "expired")
          			   #f))
          	  (simple-format #t "Timeout ~A\n" (await))
          	  (event-post! (lambda ()
          			 (resume (+ 1 1))))

          	  (simple-format #t "1 + 1 is ~A\n" (await))))
          (event-loop-run!)

     or this, where the two asynchronous operations are to run
     concurrently (the summing of 1 and 1 will finish before the
     timeout):

          (set-default-event-loop!) ;; if none has yet been set
          (a-sync (lambda (await resume)
          	  (timeout-post! 100
          			 (lambda ()
          			   (resume "expired")
          			   #f))
          	  (simple-format #t "Timeout ~A\n" (await))))
          (a-sync (lambda (await resume)
          	  (event-post! (lambda ()
          			 (resume (+ 1 1))))
          	  (simple-format #t "1 + 1 is ~A\n" (await))))

          (event-loop-run!)

     or this, to loop asynchronously with a series of results:

          (set-default-event-loop!) ;; if none has yet been set
          (event-loop-block! #t) ;; worker thread in operation
          (a-sync (lambda (await resume)
          	  ;; executing task in event loop thread
          	  (let loop ((count 0))
          	    (if (< count 5)
          		(begin
          		  (event-post! (lambda () (resume (* 2 count))))
          		  (loop (1+ count)))
          		(event-post! (lambda () (resume 'stop-iteration)))))
          	  (let loop ()
          	    (let ((res (await)))
          	      (when (not (eq? 'stop-iteration res))
          		(display res)(newline)
          		(loop))))

          	  ;; executing task in a worker thread
          	  (call-with-new-thread
          	   (lambda ()
          	     (let loop ((count 5))
          	       (if (< count 10)
          		   (begin
          		     (event-post! (lambda () (resume (* 2 count))))
          		     (loop (1+ count)))
          		   (event-post! (lambda () (resume 'stop-iteration)))))))
          	  (let loop ()
          	    (let ((res (await)))
          	      (when (not (eq? 'stop-iteration res))
          		(display res)(newline)
          		(loop))))
          	  (event-loop-block! #f)))
          (event-loop-run!)

     Or better, for many use cases when composing on the event loop from
     the *note event-loop: event loop. module, you can use the await
     helper procedures, as follows (in this example the two asynchronous
     operations run consecutively):

          (set-default-event-loop!) ;; if none has yet been set
          (a-sync (lambda (await resume)
          	  (simple-format #t
          			 "Timeout ~A\n"
          			 (await-timeout! await resume
          					 100
          					 (lambda ()
          					   "expired")))
          	  (simple-format #t "1 + 1 is ~A\n"
          			 (await-task! await resume
          				      (lambda ()
          					(+ 1 1))))))
          (event-loop-run!)

     or this, where the two asynchronous operations run concurrently
     (the summing of 1 and 1 will finish before the timeout)

          (set-default-event-loop!) ;; if none has yet been set
          (a-sync (lambda (await resume)
          	  (simple-format #t
          			 "Timeout ~A\n"
          			 (await-timeout! await resume
          					 100
          					 (lambda ()
          					   "expired")))))
          (a-sync (lambda (await resume)
          	  (simple-format #t "1 + 1 is ~A\n"
          			 (await-task! await resume
          				      (lambda ()
          					(+ 1 1))))))
          (event-loop-run!)

     or this, to loop asynchronously with a series of results:

          (set-default-event-loop!) ;; if none has yet been set
          (event-loop-block! #t) ;; worker thread in operation
          (a-sync (lambda (await resume)
          	  (await-generator! await resume
          			    (lambda (yield)
          			      (let loop ((count 0))
          				(when (< count 5)
          				  (yield (* 2 count))
          				  (loop (1+ count)))))
          			    (lambda (val)
          			      (display val)
          			      (newline)))
                    (await-generator-in-thread! await resume
          				      (lambda (yield)
          					(let loop ((count 5))
          					  (when (< count 10)
          					    (yield (* 2 count))
          					    (loop (1+ count)))))
          				      (lambda (val)
          					(display val)
          					(newline)))
          	  (event-loop-block! #f)))
          (event-loop-run!)

     Or the compose-a-sync macro in the *note compose: compose. module
     can be used so that these examples are constructed as follows (in
     this first case the two asynchronous operations run consecutively)

          (set-default-event-loop!) ;; if none has yet been set
          (compose-a-sync ((ret1 (await-timeout! 100
          				       (lambda ()
          					 "expired")))
          		 (ignore ((no-await (simple-format #t "Timeout ~A\n" ret1))))
          		 (ret2 (await-task! (lambda ()
          				      (+ 1 1)))))
          	   ((no-await (simple-format #t "1 + 1 is ~A\n" ret2))))
          (event-loop-run!)

     and this, where the two asynchronous operations run concurrently
     (the summing of 1 and 1 will finish before the timeout)

          (set-default-event-loop!) ;; if none has yet been set
          (compose-a-sync ((ret (await-timeout! 100
          				      (lambda ()
          				        "expired"))))
          	   ((no-await (simple-format #t "Timeout ~A\n" ret))))
          (compose-a-sync ((ret (await-task! (lambda ()
          				     (+ 1 1)))))
          	   ((no-await (simple-format #t "1 + 1 is ~A\n" ret))))
          (event-loop-run!)

     or this, to loop asynchronously with a series of results:

          (set-default-event-loop!) ;; if none has yet been set
          (event-loop-block! #t) ;; worker thread in operation
          (compose-a-sync ()
          		(await-generator! (lambda (yield)
          				    (let loop ((count 0))
          				      (when (< count 5)
          					(yield (* 2 count))
          					(loop (1+ count)))))
          				  (lambda (val)
          				    (display val)
          				    (newline)))
          		(await-generator-in-thread! (lambda (yield)
          					      (let loop ((count 5))
          						(when (< count 10)
          						  (yield (* 2 count))
          						  (loop (1+ count)))))
          					    (lambda (val)
          					      (display val)
          					      (newline)))
          		((no-await (event-loop-block! #f))))
          (event-loop-run!)

     The a-sync procedure can be used with any event loop, including the
     glib event loop provided by guile-gnome and so with gtk+ callbacks,
     and with the event loop in the event-loop module.

     For a further overview of the operation of 'a-sync', see the *note
     general overview: overview.


File: guile-a-sync3.info,  Node: event loop,  Next: await ports,  Prev: overview,  Up: Top

The (a-sync event-loop) module provides an event loop for asynchronous
operations.  The event loop does not of itself start any new threads.
Instead it runs in the thread which calls event-loop-run!: that
procedure will block while there are events to be processed.  In most
programs the event loop will run in the main program thread, with which
the program began.  Many programs using event loops are entirely single
threaded.

   However, the event loop provided by this module does support multiple
threads.  Most of the event loop procedures in this module are thread
safe and may be called in any thread.  The thread safe procedures are
event-loop-run!  (as mentioned, this will cause the event loop to run in
the thread which calls it), event-loop-block!, event-loop-quit!,
event-post!, event-loop-tasks, event-loop-add-read-watch!,
event-loop-add-write-watch!, event-loop-remove-read-watch!,
event-loop-remove-write-watch!, timeout-post!  and timeout-remove!.  In
particular, event-post!  allows worker threads to post an event to an
event loop, say with the result of a computation, so that the event
callback will execute in the event loop thread.

   *note (a-sync meeting): meeting. provides synchronization facilities
for event loops constructed under this module.

   The file watches provided by this module use guile's wrapper for the
select() system call.  This has two consequences.  First, in linux
select() applied to sockets can give rise to spurious wake-ups, which
means that it may be best with sockets to set the socket as non-blocking
using the guile wrapper for the fcntl() system call in order to prevent
a blocking read where it is not expected.  With guile-3.0 this means
that with such sockets, suspendable ports should be used with the
await-read-suspendable!  or await-write-suspendable!  procedures in the
*note (a-sync await-ports): await ports. module.  Secondly, with
select() the file descriptor value of a port passed to the watch should
not exceed FD_SETSIZE. Normally, by default the maximum soft user limit
for open files is the same as FD_SETSIZE, and it is best if this
situation is retained by user code.

   Where a file watch on a file descriptor or port has been added with
event-loop-add-read-watch!  or event-loop-add-write-watch!, the event
loop should be treated as owning the descriptor or port until it has
subsequently been removed with event-loop-remove-read-watch!  or
event-loop-remove-write-watch!.  In particular, if the watch is on a
port, an error in the fileno or select procedures will arise at some
point if the port is closed (say by calling close, close-port,
close-input-port or close-output-port) before its watch has been removed
from the event loop; if the watch is on a file descriptor and the
descriptor value is reused by the operating system, there may be a
phantom watch on the new descriptor.  Also note that, where a watch on a
port has just been removed, it is usually undesirable to close the port
in a different thread than the event loop thread because there is no
easy way of synchronizing the threads at that point.  If it is necessary
for a worker thread to close a port after removing the watch, one
approach is for the thread to post the closing as an event using
event-post!.

   Including this module will automatically enable suspendable ports.
The uninstall-suspendable-ports!  procedure should not subsequently be
applied, or the procedures in this module (and in the (a-sync
await-ports) module) will not work correctly.

   This module provides the following procedures:

 -- Scheme Procedure: set-default-event-loop! [loop]
     The 'loop' (event loop) argument is optional.  This procedure sets
     the default event loop for the procedures in this module to the one
     passed in (which must have been constructed by the make-event-loop
     procedure), or if no argument is passed (or #f is passed), a new
     event loop will be constructed for you as the default, which can be
     accessed via the get-default-event-loop procedure.  The default
     loop variable is not a fluid or a parameter - it is intended that
     the default event loop is the same for every thread in the program,
     and that the default event loop would normally run in the thread
     with which the program started.  This procedure is not thread safe
     - if it might be called by a different thread from others which
     might access the default event loop, then external synchronization
     may be required.  However, that should not normally be an issue.
     The normal course would be to call this procedure once only on
     program start up, before other threads have started.  It is usually
     a mistake to call this procedure twice: if there are asynchronous
     events pending (that is, if event-loop-run!  has not returned) you
     will probably not get the results you expect.

     Note that if a default event-loop is constructed for you because no
     argument is passed (or #f is passed), no throttling arguments are
     applied to it (see the documentation on make-event-loop for more
     about that).  If throttling is wanted, the make-event-loop
     procedure should be called explicitly and the result passed to this
     procedure.

 -- Scheme Procedure: get-default-event-loop
     This returns the default loop set by the set-default-event-loop!
     procedure, or #f if none has been set.

 -- Scheme Procedure: make-event-loop [throttle-threshold
          throttle-delay]
     This procedure constructs a new event loop object.

     This procedure optionally takes two throttling arguments for
     backpressure when applying the event-post!  procedure to the event
     loop.  The 'throttle-threshold' argument specifies the number of
     unexecuted tasks queued for execution, by virtue of calls to
     event-post!, at which throttling will first be applied.  Where the
     threshold is exceeded, throttling proceeds by adding a wait to any
     thread which calls the event-post!  procedure, equal to the cube of
     the number of times (if any) by which the number of queued tasks
     exceeds the threshold multiplied by the value of 'throttle-delay'.
     The value of 'throttle-delay' should be given in microseconds.
     Throttling is only applied where the call to event-post!  is made
     in a thread other than the one in which the event loop runs.

     So if the threshold given is 10000 tasks and the delay given is
     1000 microseconds, upon 10000 unexecuted tasks accumulating a delay
     of 1000 microseconds will be applied to callers of event-post!
     which are not in the event loop thread, at 20000 unexecuted tasks a
     delay of 8000 microseconds will be applied, and at 30000 unexecuted
     tasks a delay of 27000 microseconds will be applied, and so on.

     If throttle-threshold and throttle-delay arguments are not provided
     (or #f is passed for them), then no throttling takes place.

 -- Scheme Procedure: event-loop? obj
     This procedure indicates whether 'obj' is an event-loop object
     constructed by make-event-loop.

 -- Scheme Procedure: event-loop-run! [loop]
     The 'loop' (event loop) argument is optional.  This procedure
     starts the event loop passed in as an argument, or if none is
     passed (or #f is passed) it starts the default event loop.  The
     event loop will run in the thread which calls this procedure.  If
     this procedure has returned, including after a call to
     event-loop-quit!, this procedure may be called again to restart the
     event loop, provided event-loop-close!  has not been applied to the
     loop.  If event-loop-close!  has previously been invoked, this
     procedure will throw an 'event-loop-error exception.  This
     procedure will also throw an 'event-loop-error exception if it is
     applied to an event loop which is currently running.

     If something else throws in the implementation or a callback
     throws, then this procedure will clean up the event loop as if
     event-loop-quit!  had been called, and the exception will be
     rethrown out of this procedure.

 -- Scheme Procedure: event-loop-add-read-watch! file proc [loop]
     The 'loop' (event loop) argument is optional.  This procedure will
     start a read watch in the event loop passed in as an argument, or
     if none is passed (or #f is passed), in the default event loop.
     The 'proc' callback should take a single argument, and when called
     this will be set to 'in or 'excpt.  The same port or file
     descriptor can also be passed to event-loop-add-write-watch, and if
     so and the descriptor is also available for writing, the write
     callback will also be called with its argument set to 'out.  If
     there is already a read watch for the file passed, the old one will
     be replaced by the new one.  If 'proc' returns #f, the read watch
     will be removed from the event loop, otherwise the watch will
     continue.  This is thread safe - any thread may add a watch, and
     the callback will execute in the event loop thread.  The file
     argument can be either a port or a file descriptor.  If 'file' is a
     file descriptor, any port for the descriptor is not referenced for
     garbage collection purposes - it must remain valid while operations
     are carried out on the descriptor.  If 'file' is a buffered port,
     buffering will be taken into account in indicating whether a read
     can be made without blocking (but on a buffered port, for
     efficiency purposes each read operation in response to this watch
     should usually exhaust the buffer by calling drain-input or by
     looping on char-ready?, or the port's ordinary input procedures
     should be used with suspendable ports using the
     await-read-suspendable!  procedure in the *note (a-sync
     await-ports): await ports. module).

     This procedure should not throw an exception unless memory is
     exhausted.

 -- Scheme Procedure: event-loop-add-write-watch! file proc [loop]
     The 'loop' (event loop) argument is optional.  This procedure will
     start a write watch in the event loop passed in as an argument, or
     if none is passed (or #f is passed), in the default event loop.
     The 'proc' callback should take a single argument, and when called
     this will be set to 'out or 'excpt.  The same port or file
     descriptor can also be passed to event-loop-add-read-watch, and if
     so and the descriptor is also available for reading or in
     exceptional condition, the read callback will also be called with
     its argument set to 'in or 'excpt (if both a read and a write watch
     have been set for the same file argument, and there is an
     exceptional condition, it is the read watch procedure which will be
     called with 'excpt rather than the write watch procedure, so if
     that procedure returns #f only the read watch will be removed).  If
     there is already a write watch for the file passed, the old one
     will be replaced by the new one.  If 'proc' returns #f, the write
     watch will be removed from the event loop, otherwise the watch will
     continue.  This is thread safe - any thread may add a watch, and
     the callback will execute in the event loop thread.  The file
     argument can be either a port or a file descriptor.  If 'file' is a
     file descriptor, any port for the descriptor is not referenced for
     garbage collection purposes - it must remain valid while operations
     are carried out on the descriptor.

     If 'file' is a buffered port, buffering will be taken into account
     in indicating whether a write can be made without blocking, either
     because there is room in the buffer for a character, or because the
     underlying file descriptor is ready for a character.  This can have
     unintended consequences: if the buffer is full but the underlying
     file descriptor is ready for a character, the next write will cause
     a buffer flush, and if the size of the buffer is greater than the
     number of characters that the file can receive without blocking,
     blocking might still occur.  Unless the port will carry out a
     partial flush in such a case, this procedure will therefore
     generally work best either with unbuffered ports (say by using the
     open-file, fdopen or duplicate-port procedure with the '0' mode
     option or the R6RS open-file-input-port procedure with a
     buffer-mode of none, or by calling setvbuf), or the port's ordinary
     output procedures should be used with suspendable ports using the
     await-write-suspendable!  procedure in the *note (a-sync
     await-ports): await ports. module.

     This procedure should not throw an exception unless memory is
     exhausted.

 -- Scheme Procedure: event-loop-remove-read-watch! file [loop]
     The 'loop' (event loop) argument is optional.  This procedure will
     remove a read watch from the event loop passed in as an argument,
     or if none is passed (or #f is passed), from the default event
     loop.  The file argument may be a port or a file descriptor.  This
     is thread safe - any thread may remove a watch.  A file descriptor
     and a port with the same underlying file descriptor compare equal
     for the purposes of removal.

     This procedure should not throw an exception unless memory is
     exhausted.

 -- Scheme Procedure: event-loop-remove-write-watch! file [loop]
     The 'loop' (event loop) argument is optional.  This procedure will
     remove a write watch from the event loop passed in as an argument,
     or if none is passed (or #f is passed), from the default event
     loop.  The file argument may be a port or a file descriptor.  This
     is thread safe - any thread may remove a watch.  A file descriptor
     and a port with the same underlying file descriptor compare equal
     for the purposes of removal.

     This procedure should not throw an exception unless memory is
     exhausted.

 -- Scheme Procedure: event-post! action [loop]
     The 'loop' (event loop) argument is optional.  This procedure will
     post a callback for execution in the event loop passed in as an
     argument, or if none is passed (or #f is passed), in the default
     event loop.  The 'action' callback is a thunk.  This is thread safe
     - any thread may post an event (that is its main purpose), and the
     action callback will execute in the event loop thread.  Actions
     execute in the order in which they were posted.  If an event is
     posted from a worker thread, it will normally be necessary to call
     event-loop-block!  beforehand.

     This procedure should not throw an exception unless memory is
     exhausted.  If the 'action' callback throws, and the exception is
     not caught locally, it will propagate out of event-loop-run!.

     Where this procedure is called by other than the event loop thread,
     throttling may take place if the number of posted callbacks waiting
     to execute exceeds the threshold set for the event loop - see the
     documentation on make-event-loop for further details.

 -- Scheme Procedure: timeout-post! msecs action [loop]
     The 'loop' (event loop) argument is optional.  This procedure adds
     a timeout to the event loop passed in as an argument, or if none is
     passed (or #f is passed), to the default event loop.  The timeout
     will repeat unless and until the passed-in callback returns #f or
     timeout-remove!  is called.  The passed-in callback must be a
     thunk.  This procedure returns a tag symbol to which
     timeout-remove!  can be applied.  It may be called by any thread,
     and the timeout callback will execute in the event loop thread.

     This procedure should not throw an exception unless memory is
     exhausted.  If the 'action' callback throws, and the exception is
     not caught locally, it will propagate out of event-loop-run!.

 -- Scheme Procedure: timeout-remove! tag [loop]
     The 'loop' (event loop) argument is optional.  This procedure stops
     the timeout with the given tag from executing in the event loop
     passed in as an argument, or if none is passed (or #f is passed),
     in the default event loop.  It may be called by any thread.

     This procedure should not throw an exception unless memory is
     exhausted.

 -- Scheme Procedure: event-loop-tasks [loop]
     This procedure returns the number of callbacks posted to an event
     loop with the event-post!  procedure which at the time still remain
     queued for execution.  Amongst other things, it can be used by a
     calling thread which is not the event loop thread to determine
     whether throttling is likely to be applied to it when calling
     event-post!  - see the documentation on make-event-loop for further
     details.

     The 'loop' (event loop) argument is optional: this procedure
     operates on the event loop passed in as an argument, or if none is
     passed (or #f is passed), on the default event loop.  This
     procedure is thread safe - any thread may call it.

 -- Scheme Procedure: event-loop-block! val [loop]
     By default, upon there being no more watches, timeouts and posted
     events for an event loop, event-loop-run!  will return, which is
     normally what you want with a single threaded program.  However,
     this is undesirable where a worker thread is intended to post an
     event to the main loop after it has reached a result, say via
     await-task-in-thread!, because the main loop may have ended before
     it posts.  Passing #t to the val argument of this procedure will
     prevent that from happening, so that the event loop can only be
     ended by calling event-loop-quit!, or by calling event-loop-block!
     again with a #f argument (to switch the event loop back to
     non-blocking mode, pass #f).  This is thread safe - any thread may
     call this procedure.  The 'loop' (event loop) argument is optional:
     this procedure operates on the event loop passed in as an argument,
     or if none is passed (or #f is passed as the 'loop' argument), on
     the default event loop.

     This procedure should not throw an exception unless memory is
     exhausted.

 -- Scheme Procedure: event-loop-quit! [loop]
     This procedure causes an event loop to end and event-loop-run!  to
     return.  Any file watches, timeouts or posted events remaining in
     the event loop will be discarded.  New file watches, timeouts and
     events may subsequently be added or posted after event-loop-run!
     has returned, and event-loop-run!  then called for them.  This is
     thread safe - any thread may call this procedure, including any
     callback or task running on the event loop.  The 'loop' argument is
     optional: this procedure operates on the event loop passed in as an
     argument, or if none is passed (or #f is passed), on the default
     event loop.  Applying this procedure to an event loop does not
     change the blocking status of the loop as may previously have been
     set by event-loop-block!, should event-loop-run!  be applied to it
     again.

     Applying this procedure to an event loop has no effect if the event
     loop is not actually running.  Unlike the await-* procedures in
     this module, the await-* procedures in the *note (a-sync
     await-ports): await ports. module do not pass control to the event
     loop if they can operate immediately without waiting, so if (i) the
     event loop concerned has been set blocking by event-loop-block!,
     (ii) this procedure is invoked in an a-sync or compose-a-sync block
     in order to bring the event loop to an end, and (iii) before
     invoking this procedure the a-sync or compose-a-sync block has done
     nothing except make a call to one or more of the await-* procedures
     in the *note (a-sync await-ports): await ports. module, then in
     order to make sure the loop is running consider calling
     await-yield!  or some similar procedure before applying this
     procedure.

     Note that the discarding of file watches, timeouts and unexecuted
     events remaining in the event loop means that if one of the helper
     await-* procedures provided by this library has been called but has
     not yet returned, it may fail to complete, as its continuation may
     disappear - it will be as if the a-sync or compose-a-sync block
     concerned had come to an end.  It may therefore be best only to
     call this procedure on an event loop after all await-* procedures
     which are executing in it have returned.

     This procedure should not throw an exception unless memory is
     exhausted.

 -- Scheme Procedure: event-loop-close! [loop]
     This procedure closes an event loop.  Like event-loop-quit!, if the
     loop is still running it causes the event loop to unblock, and any
     file watches, timeouts or posted events remaining in the event loop
     will be discarded.  However, unlike event-loop-quit!, it also
     closes the internal event pipe ports, and any subsequent
     application of event-loop-run!  to the event loop will cause an
     'event-loop-error exception to be thrown.

     You might want to call this procedure to ensure that, after an
     event loop in a local scope has been finished with, the two
     internal event pipe file descriptors used by the loop are released
     to the operating system in advance of the garbage collector
     releasing them when the event loop object becomes inaccessible.

     This is thread safe - any thread may call this procedure, including
     any callback or task running on the event loop.  The 'loop'
     argument is optional: this procedure operates on the event loop
     passed in as an argument, or if none is passed (or #f is passed),
     on the default event loop.

     Note that the discarding of file watches, timeouts and unexecuted
     events remaining in the event loop means that if one of the helper
     await-* procedures provided by this library has been called but has
     not yet returned, it may fail to complete, as its continuation may
     disappear - it will be as if the a-sync or compose-a-sync block
     concerned had come to an end.  It may therefore be best only to
     call this procedure on an event loop after all such await-*
     procedures which are executing have returned.

     This procedure should not throw an exception unless memory is
     exhausted.

 -- Scheme Procedure: await-task-in-thread! await resume [loop] thunk
          [handler]
     The loop and handler arguments are optional.  The procedure will
     run 'thunk' in its own thread, and then post an event to the event
     loop specified by the 'loop' argument when 'thunk' has finished, or
     to the default event loop if no 'loop' argument is provided or if
     #f is provided as the 'loop' argument (pattern matching is used to
     detect the type of the third argument).  This procedure calls
     'await' and will return the thunk's return value.  It is intended
     to be called within a waitable procedure invoked by a-sync (which
     supplies the 'await' and 'resume' arguments).  It will normally be
     necessary to call event-loop-block!  before invoking this
     procedure.  If the optional 'handler' argument is provided, then
     that handler will be run in the event loop thread if 'thunk' throws
     and the return value of the handler would become the return value
     of this procedure; otherwise the program will terminate if an
     unhandled exception propagates out of 'thunk'.  'handler' should
     take a single argument, which will be the thrown exception object.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the event loop runs, where the result
     of calling 'thunk' will be received.  As mentioned above, the thunk
     itself will run in its own thread.

     As the worker thread calls event-post!, it might be subject to
     throttling by the event loop concerned.  See the documentation on
     the make-event-loop procedure for further information about that.

     Exceptions may propagate out of this procedure if they arise while
     setting up (that is, before the worker thread starts), which
     shouldn't happen unless memory is exhausted or pthread has run out
     of resources.  Exceptions arising during execution of the task, if
     not caught by a handler procedure, will terminate the program.
     Exceptions thrown by the handler procedure will propagate out of
     event-loop-run!.

     Here is an example of the use of await-task-in-thread!:
          (set-default-event-loop!) ;; if none has yet been set
          (event-loop-block! #t) ;; because the task runs in another thread
          (a-sync (lambda (await resume)
          	  (simple-format #t "1 + 1 is ~A\n"
          			 (await-task-in-thread! await resume
          						(lambda ()
          						  (+ 1 1))))
          	  (event-loop-block! #f)))
          (event-loop-run!)

 -- Scheme Procedure: await-task-in-event-loop! await resume [waiter]
          worker thunk
     The 'waiter' argument is optional.  The 'worker' argument is an
     event loop running in a different thread than the one in which this
     procedure is called, and is the one in which 'thunk' will be
     executed by posting an event to that loop.  The result of executing
     'thunk' will then be posted to the event loop specified by the
     'waiter' argument, or to the default event loop if no 'waiter'
     argument is provided or if #f is provided as the 'waiter' argument,
     and will comprise this procedure's return value.  This procedure is
     intended to be called within a waitable procedure invoked by a-sync
     (which supplies the 'await' and 'resume' arguments).  It will
     normally be necessary to call event-loop-block!  on 'waiter' (or on
     the default event loop) before invoking this procedure.

     This procedure calls 'await' and must (like the a-sync procedure)
     be called in the same thread as that in which the 'waiter' or
     default event loop runs (as the case may be).

     This procedure acts as a form of channel through which two
     different event loops may communicate.  It also offers a means by
     which a master event loop (the waiter or default event loop) may
     allocate work to worker event loops for execution.

     Depending on the circumstances, it may be desirable to provide
     throttling arguments when constructing the 'worker' event loop, in
     order to enable backpressure to be supplied if the 'worker' event
     loop becomes overloaded: see the documentation on the
     make-event-loop procedure for further information about that.
     (This procedure calls event-post!  in both the 'waiter' and
     'worker' event loops by the respective threads of the other, so
     either could be subject to throttling.)

     Exceptions may propagate out of this procedure if they arise while
     setting up, which shouldn't happen unless memory is exhausted or
     pthread has run out of resources.  Exceptions arising during
     execution of the task, if not caught locally, will propagate out of
     the event-loop-run!  procedure called for the 'worker' event loop.

     Here is an example of the use of await-task-in-event-loop!:
          (set-default-event-loop!)     ;; if none has yet been set
          (define worker (make-event-loop))
          (event-loop-block! #t)        ;; because the task runs in another thread
          (event-loop-block! #t worker)

          (call-with-new-thread
           (lambda ()
             (event-loop-run! worker)))

          (a-sync (lambda (await resume)
          	  (let ((res
          		 (await-task-in-event-loop! await resume worker
          					    (lambda ()
          					      (+ 5 10)))))
          	    (simple-format #t "~A\n" res)
          	    (event-loop-block! #f worker)
          	    (event-loop-block! #f))))
          (event-loop-run!)

 -- Scheme Procedure: await-task! await resume [loop] thunk
     The 'loop' argument is optional.  This is a convenience procedure
     for use with an event loop, which will run 'thunk' in the event
     loop specified by the 'loop' argument, or in the default event loop
     if no 'loop' argument is provided or #f is provided as the 'loop'
     argument.  This procedure calls 'await' and will return the thunk's
     return value.  It is intended to be called within a waitable
     procedure invoked by a-sync (which supplies the 'await' and
     'resume' arguments).  It is the single-threaded corollary of
     await-task-in-thread!.  This means that (unlike with
     await-task-in-thread!)  while 'thunk' is running other events in
     the event loop will not make progress, so blocking calls should not
     be made in 'thunk'.

     This procedure can be used for the purpose of implementing
     co-operative multi-tasking.  However, when 'thunk' is executed,
     this procedure is waiting on 'await', so 'await' and 'resume'
     cannot be used again in 'thunk' (although 'thunk' can call a-sync
     to start another series of asynchronous operations with a new
     await-resume pair).  For that reason, await-yield!  is usually more
     convenient for composing asynchronous tasks.  In retrospect, this
     procedure offers little over await-yield!, apart from symmetry with
     await-task-in-thread!.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the event loop runs.

     This procedure calls event-post!  in the event loop concerned.
     This is done in the same thread as that in which the event loop
     runs so it cannot of itself be throttled.  However it may
     contribute to the number of accumulated unexecuted tasks in the
     event loop and therefore contribute to the throttling of other
     threads by the loop.  See the documentation on the make-event-loop
     procedure for further information about that.

     Exceptions may propagate out of this procedure if they arise while
     setting up (that is, before the task starts), which shouldn't
     happen unless memory is exhausted.  Exceptions arising during
     execution of the task, if not caught locally, will propagate out of
     event-loop-run!.

     Here is an example of the use of await-task!:
          (set-default-event-loop!) ;; if none has yet been set
          (a-sync (lambda (await resume)
          	  (simple-format #t "1 + 1 is ~A\n"
          			 (await-task! await resume
          				      (lambda ()
          					(+ 1 1))))))
          (event-loop-run!)

 -- Scheme Procedure: await-yield! await resume [loop]
     This is a convenience procedure which will surrender execution to
     the relevant event loop, so that code in other a-sync or
     compose-a-sync blocks can run.  The remainder of the code after the
     call to await-yield!  in the current a-sync or compose-a-sync block
     will execute on the next iteration through the loop.  It is
     intended to be called within a waitable procedure invoked by a-sync
     (which supplies the 'await' and 'resume' arguments).  It's effect
     is similar to calling await-task!  with a task that does nothing.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the relevant event loop runs: for this
     purpose "the relevant event loop" is the event loop given by the
     'loop' argument, or if no 'loop' argument is provided or #f is
     provided as the 'loop' argument, then the default event loop.

     This procedure calls event-post!  in the event loop concerned.
     This is done in the same thread as that in which the event loop
     runs so it cannot of itself be throttled.  However it may
     contribute to the number of accumulated unexecuted tasks in the
     event loop and therefore contribute to the throttling of other
     threads by the loop.  See the documentation on the make-event-loop
     procedure for further information about that.

     This procedure should not throw any exceptions unless memory is
     exhausted.

     Here is an example of the use of await-yield!:
          (set-default-event-loop!) ;; if none has yet been set
          (a-sync (lambda (await resume)
          	  (display "In first iteration through event loop\n")
          	  (await-yield! await resume)
          	  (display "In next iteration through event loop\n")))
          (event-loop-run!)

 -- Scheme Procedure: await-generator-in-thread! await resume [loop]
          generator proc [handler]
     The 'loop' and 'handler' arguments are optional.  The 'generator'
     argument is a procedure taking one argument, namely a yield
     argument (see the documentation on the make-iterator procedure for
     further details).  This await-generator-in-thread!  procedure will
     run 'generator' in its own worker thread, and whenever 'generator'
     yields a value will cause 'proc' to execute in the event loop
     specified by the 'loop' argument (or in the default event loop if
     no 'loop' argument is provided or if #f is provided as the 'loop'
     argument - pattern matching is used to detect the type of the third
     argument).

     'proc' should be a procedure taking a single argument, namely the
     value yielded by the generator.  If the optional 'handler' argument
     is provided, then that handler will be run in the event loop thread
     if 'generator' throws; otherwise the program will terminate if an
     unhandled exception propagates out of 'generator'.  'handler'
     should take a single argument, which will be the thrown exception
     object.

     This procedure calls 'await' and will return when the generator has
     finished or, if 'handler' is provided, upon the generator throwing
     an exception.  This procedure will return #f if the generator
     completes normally, or 'guile-a-sync-thread-error if the generator
     throws an exception and 'handler' is run (the
     'guile-a-sync-thread-error symbol is reserved to the implementation
     and should not be yielded by the generator).

     This procedure is intended to be called within a waitable procedure
     invoked by a-sync (which supplies the 'await' and 'resume'
     arguments).  It will normally be necessary to call
     event-loop-block!  before invoking this procedure.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the event loop runs.  As mentioned
     above, the generator itself will run in its own thread.

     As the worker thread calls event-post!, it might be subject to
     throttling by the event loop concerned.  See the documentation on
     the make-event-loop procedure for further information about that.

     Exceptions may propagate out of this procedure if they arise while
     setting up (that is, before the worker thread starts), which
     shouldn't happen unless memory is exhausted or pthread has run out
     of resources.  Exceptions arising during execution of the
     generator, if not caught by a handler procedure, will terminate the
     program.  Exceptions thrown by the handler procedure will propagate
     out of event-loop-run!.  Exceptions thrown by 'proc', if not caught
     locally, will also propagate out of event-loop-run!.

     Here is an example of the use of await-generator-in-thread!:
          (set-default-event-loop!) ;; if none has yet been set
          (event-loop-block! #t) ;; because the generator runs in another thread
          (a-sync (lambda (await resume)
                    (await-generator-in-thread! await resume
          				      (lambda (yield)
          					(let loop ((count 0))
          					  (when (< count 5)
          					    (yield (* 2 count))
          					    (loop (1+ count)))))
          				      (lambda (val)
          					(display val)
          					(newline)))
          	  (event-loop-block! #f)))
          (event-loop-run!)

 -- Scheme Procedure: await-generator-in-event-loop! await resume
          [waiter] worker generator proc
     The 'waiter' argument is optional.  The 'worker' argument is an
     event loop running in a different thread than the one in which this
     procedure is called.  The 'generator' argument is a procedure
     taking one argument, namely a yield argument (see the documentation
     on the make-iterator procedure for further details).  This
     await-generator-in-event-loop!  procedure will cause 'generator' to
     run in the 'worker' event loop, and whenever 'generator' yields a
     value this will cause 'proc' to execute in the event loop specified
     by the 'waiter' argument, or in the default event loop if no
     'waiter' argument is provided or if #f is provided as the 'waiter'
     argument.  'proc' should be a procedure taking a single argument,
     namely the value yielded by the generator.

     This procedure is intended to be called within a waitable procedure
     invoked by a-sync (which supplies the 'await' and 'resume'
     arguments).  It will normally be necessary to call
     event-loop-block!  on 'waiter' (or on the default event loop)
     before invoking this procedure.

     This procedure calls 'await' and will return when the generator has
     finished.  It must (like the a-sync procedure) be called in the
     same thread as that in which the 'waiter' or default event loop
     runs (as the case may be).

     This procedure acts, with await-task-in-event-loop!, as a form of
     channel through which two different event loops may communicate.
     It also offers a means by which a master event loop (the waiter or
     default event loop) may allocate work to worker event loops for
     execution.

     Depending on the circumstances, it may be desirable to provide
     throttling arguments when constructing the 'worker' event loop, in
     order to enable backpressure to be supplied if the 'worker' event
     loop becomes overloaded: see the documentation on the
     make-event-loop procedure for further information about that.
     (This procedure calls event-post!  in both the 'waiter' and
     'worker' event loops by the respective threads of the other, so
     either could be subject to throttling.)

     Exceptions may propagate out of this procedure if they arise while
     setting up, which shouldn't happen unless memory is exhausted or
     pthread has run out of resources.  Exceptions arising during
     execution of the generator, if not caught locally, will propagate
     out of the event-loop-run!  procedure called for the 'worker' event
     loop.  Exceptions arising during the execution of 'proc', if not
     caught locally, will propagate out of the event-loop-run!
     procedure called for the 'waiter' or default event loop, as the
     case may be.

     Here is an example of the use of await-generator-in-event-loop!:
          (set-default-event-loop!)     ;; if none has yet been set
          (define worker (make-event-loop))
          (event-loop-block! #t)        ;; because the generator runs in another thread
          (event-loop-block! #t worker)

          (call-with-new-thread
           (lambda ()
             (event-loop-run! worker)))

          (a-sync (lambda (await resume)
          	  (await-generator-in-event-loop! await resume worker
          					  (lambda (yield)
          					    (let loop ((count 0))
          					      (when (< count 5)
          						(yield (* 2 count))
          						(loop (1+ count)))))
          					  (lambda (val)
          					    (display val)
          					    (newline)))
          	  (event-loop-block! #f worker)
          	  (event-loop-block! #f)))
          (event-loop-run!)

 -- Scheme Procedure: await-generator! await resume [loop] generator
          proc
     The 'loop' argument is optional.  The 'generator' argument is a
     procedure taking one argument, namely a yield argument (see the
     documentation on the make-iterator procedure for further details).
     This await-generator!  procedure will run 'generator', and whenever
     'generator' yields a value will cause 'proc' to execute in the
     event loop specified by the 'loop' argument, or in the default
     event loop if no 'loop' argument is provided or #f is provided as
     the 'loop' argument.  'proc' should be a procedure taking a single
     argument, namely the value yielded by the generator.  Each time
     'proc' runs it will do so as a separate event in the event loop and
     so be multi-plexed with other events.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the event loop runs.

     This procedure is intended to be called within a waitable procedure
     invoked by a-sync (which supplies the 'await' and 'resume'
     arguments).  It is the single-threaded corollary of
     await-generator-in-thread!.  This means that (unlike with
     await-generator-in-thread!)  while 'generator' is running other
     events in the event loop will not make progress, so blocking calls
     (other than to the yield procedure) should not be made in
     'generator'.  This procedure can be useful for the purpose of
     implementing co-operative multi-tasking, say by composing tasks
     with compose-a-sync (see compose.scm).

     When 'proc' executes, 'await' and 'resume' will still be in use by
     this procedure, so they may not be reused by 'proc' (even though
     'proc' runs in the event loop thread).

     This procedure calls event-post!  in the event loop concerned.
     This is done in the same thread as that in which the event loop
     runs so it cannot of itself be throttled.  However it may
     contribute to the number of accumulated unexecuted tasks in the
     event loop and therefore contribute to the throttling of other
     threads by the loop.  See the documentation on the make-event-loop
     procedure for further information about that.

     Exceptions may propagate out of this procedure if they arise while
     setting up (that is, before the task starts), which shouldn't
     happen unless memory is exhausted.  Exceptions arising during
     execution of the generator, if not caught locally, will propagate
     out of event-loop-run!.  Exceptions thrown by 'proc', if not caught
     locally, will propagate out of event-loop-run!.

     Here is an example of the use of await-generator!:
          (set-default-event-loop!) ;; if none has yet been set
          (a-sync (lambda (await resume)
          	  (await-generator! await resume
          			    (lambda (yield)
          			      (let loop ((count 0))
          				(when (< count 5)
          				  (yield (* 2 count))
          				  (loop (1+ count)))))
          			    (lambda (val)
          			      (display val)
          			      (newline)))))
          (event-loop-run!)

 -- Scheme Procedure: await-timeout! await resume [loop] msecs thunk
     This is a convenience procedure for use with an event loop, which
     will run 'thunk' in the event loop thread when the timeout expires.
     This procedure calls 'await' and will return the thunk's return
     value.  It is intended to be called within a waitable procedure
     invoked by a-sync (which supplies the 'await' and 'resume'
     arguments).  The timeout is single shot only - as soon as 'thunk'
     has run once and completed, the timeout will be removed from the
     event loop.  The 'loop' argument is optional: this procedure
     operates on the event loop passed in as an argument, or if none is
     passed (or #f is passed), on the default event loop.

     In practice, calling await-sleep!  may often be more convenient for
     composing asynchronous code than using this procedure.  That is
     because, when 'thunk' is executed, this procedure is waiting on
     'await', so 'await' and 'resume' cannot be used again in 'thunk'
     (although 'thunk' can call a-sync to start another series of
     asynchronous operations with a new await-resume pair).  In
     retrospect, this procedure offers little over await-sleep!.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the event loop runs.

     Exceptions may propagate out of this procedure if they arise while
     setting up (that is, before the first call to 'await' is made),
     which shouldn't happen unless memory is exhausted.  Exceptions
     thrown by 'thunk', if not caught locally, will propagate out of
     event-loop-run!.

     Here is an example of the use of event-timeout!:
          (set-default-event-loop!) ;; if none has yet been set
          (a-sync (lambda (await resume)
          	  (simple-format #t
          			 "Timeout ~A\n"
          			 (await-timeout! await resume
          					 100
          					 (lambda ()
          					   "expired")))))
          (event-loop-run!)

 -- Scheme Procedure: await-sleep! await resume [loop] msecs
     This is a convenience procedure which will suspend execution of
     code in the current a-sync or compose-a-sync block for the duration
     of 'msecs' milliseconds.  The event loop will not be blocked by the
     sleep - instead any other events in the event loop (including any
     other a-sync or compose-a-sync blocks) will be serviced.  It is
     intended to be called within a waitable procedure invoked by a-sync
     (which supplies the 'await' and 'resume' arguments).  The 'loop'
     argument is optional: this procedure operates on the event loop
     passed in as an argument, or if none is passed (or #f is passed),
     on the default event loop.

     Calling this procedure is equivalent to calling await-timeout!
     with a 'proc' argument comprising a lambda expression that does
     nothing.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the event loop runs.

     This procedure should not throw any exceptions unless memory is
     exhausted.

     Here is an example of the use of await-sleep!:
          (set-default-event-loop!) ;; if none has yet been set
          (a-sync (lambda (await resume)
          	  (display "Entering sleep\n")
          	  (await-sleep! await resume 500)
          	  (display "Timeout expired\n")))
          (event-loop-run!)

   The (a-sync event-loop) module also loads the *note (a-sync
monotonic-time): monotonic time. module.


File: guile-a-sync3.info,  Node: await ports,  Next: thread pool,  Prev: event loop,  Up: Top

The (a-sync await-ports) module provides procedures for using
guile-3.0's suspendable ports with event loops, and a convenient way of
using ports' normal input and output procedures with non-blocking ports.

   For this purpose, the 'normal input and output' procedures which may
be used with await-read-suspendable!  and await-write-suspendable!
cover most but not all i/o procedures.  Thus, the following are safe to
use with non-blocking suspendable ports: read-char, get-char, peek-char,
lookahead-char, read-line, get-line, get-u8, lookahead-u8,
get-bytevector-n, get-string-all, write-char, put-char, put-u8,
put-string, put-bytevector, newline, force-output and flush-output-port.
For sockets, the accept and connect procedures are also safe.

   Some others are not at present safe to use with suspendable ports,
including get-bytevector-n!, get-bytevector-some, get-bytevector-all,
get-string-n, read, write and display.  Unfortunately this means that
some of the procedures in guile's web module cannot be used with
suspendable ports.  build-uri, build-request and cognates are fine, as
is write-request if no custom header writers are imported, but the
read-response-body procedure is not.  This means that http-get, http-put
and so on cannot normally be used: an example of a safe procedure for
reading http responses is in the example-client.scm file in the docs
directory.  In addition, guile-gnutls ports are not suspendable.  (One
answer where only a few gnutls sessions are to be run concurrently is to
run each such session in a separate thread using await-task-in-thread!,
await-task-in-thread-pool!  or await-task-in-event-loop!, and to use
synchronous guile-gnutls i/o in the session.)

   Including this module will automatically enable suspendable ports.
The uninstall-suspendable-ports!  procedure should not subsequently be
applied, or the procedures in this module (and in the (a-sync
event-loop) module) will not work correctly.  Any port using these
procedures must be made non-blocking using fcntl as follows:

     (fcntl [port] F_SETFL (logior O_NONBLOCK
                           (fcntl [port] F_GETFL)))

 -- Scheme Procedure: await-read-suspendable! await resume [loop] port
          proc
     This procedure is provided to implement read file watches using
     guile-3.0's suspendable ports.  'proc' is a procedure taking a
     single argument, to which the port will be passed when it is
     invoked.  The purpose of 'proc' is to carry out i/o operations on
     'port' using the port's normal read procedures.  'port' must be a
     suspendable non-blocking port.  This procedure will return when
     'proc' returns, as if by blocking read operations.  However, the
     event loop will not be blocked by this procedure even if only
     individual characters or bytes comprising part characters are
     available for reading at any one time.  It is intended to be called
     within a waitable procedure invoked by a-sync (which supplies the
     'await' and 'resume' arguments).  'proc' must not itself explicitly
     apply 'await' and 'resume' as those are potentially in use by the
     suspendable port while 'proc' is executing.

     If an exceptional condition ('excpt) is encountered by the
     implementation, #f will be returned by this procedure and the read
     operations to be performed by 'proc' will be abandonned; there is
     however no guarantee that any exceptional condition that does arise
     will be encountered by the implementation - the user procedure
     'proc' may get there first and deal with it, or it may not.
     However exceptional conditions are very rare, usually comprising
     only out-of-band data on a TCP socket, or a pseudoterminal master
     in packet mode seeing state change in a slave.  In the absence of
     an exceptional condition, the value(s) returned by 'proc' will be
     returned ('proc' may return any number of values).

     The 'loop' argument is optional: this procedure operates on the
     event loop passed in as an argument, or if none is passed (or #f is
     passed), on the default event loop.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the event loop runs.

     Exceptions (say, from 'proc' because of port or conversion errors)
     will propagate out of this procedure in the first instance, and if
     not caught locally will then propagate out of event-loop-run!.

     Unlike the await-* procedures in the *note (a-sync event-loop):
     event loop. module, this procedure will not call 'await' if the
     read operation(s) in 'proc' can be effected immediately without
     waiting: instead, after reading this procedure would return
     straight away without invoking the event loop.

     As an example of how to use await-read-suspendable!, here is the
     implementation of await-getline!:

          (define await-getline!
            (case-lambda
              ((await resume port)
               (await-getline! await resume #f port))
              ((await resume loop port)
               (await-read-suspendable! await resume loop port
          			      (lambda (p)
          				(read-line p))))))

 -- Scheme Procedure: await-getline! await resume [loop] port
     This procedure is provided mainly to retain compatibility with the
     guile-a-sync library for guile-2.0, because it is trivial to
     implement with await-read-suspendable!  (and is implemented by
     await-read-suspendable!).

     It is intended to be called within a waitable procedure invoked by
     a-sync (which supplies the 'await' and 'resume' arguments), and
     reads a line of text from a non-blocking suspendable port and
     returns it (without the terminating '\n' character).  The 'loop'
     argument is optional: this procedure operates on the event loop
     passed in as an argument, or if none is passed (or #f is passed),
     on the default event loop.  If an exceptional condition ('excpt) is
     encountered by the implementation, #f will be returned by this
     procedure and the read operation will be abandonned.  See the
     documentation on the await-read-suspendable!  procedure for further
     particulars about this procedure.

     Here is an example of the use of await-getline!:
          (set-default-event-loop!) ;; if none has yet been set
          (a-sync (lambda (await resume)
          	  (display "Enter a line of text at the keyboard\n")
          	  (let ((port (open "/dev/tty" O_RDONLY)))
          	    (fcntl port F_SETFL (logior O_NONBLOCK
          				(fcntl port F_GETFL)))
          	    (simple-format #t
          			   "The line was: ~A\n"
          			   (await-getline! await resume
          					   port)))))
          (event-loop-run!)

 -- Scheme Procedure: await-geteveryline! await resume [loop] port proc
     This procedure is provided mainly to retain compatibility with the
     guile-a-sync library for guile-2.0, because it is trivial to
     implement with await-read-suspendable!  (and is implemented by
     await-read-suspendable!).

     It is intended to be called within a waitable procedure invoked by
     a-sync (which supplies the 'await' and 'resume' arguments), and
     will apply 'proc' to every complete line of text received (without
     the terminating '\n' character).  The watch will not end until
     end-of-file or an exceptional condition ('excpt) is reached.  In
     the event of that happening, this procedure will end and return an
     end-of-file object or #f respectively.  The 'loop' argument is
     optional: this procedure operates on the event loop passed in as an
     argument, or if none is passed (or #f is passed), on the default
     event loop.

     When 'proc' executes, 'await' and 'resume' will still be in use by
     this procedure, so they may not be reused by 'proc' (even though
     'proc' runs in the event loop thread).

     See the documentation on the await-read-suspendable!  procedure for
     further particulars about this procedure.

     Here is an example of the use of await-geteveryline!  (because the
     keyboard has no end-of-file, use Ctrl-C to exit this code snippet):
          (set-default-event-loop!) ;; if none has yet been set
          (a-sync (lambda (await resume)
          	  (display "Enter lines of text at the keyboard, ^C to finish\n")
          	  (let ((port (open "/dev/tty" O_RDONLY)))
          	    (fcntl port F_SETFL (logior O_NONBLOCK
          				(fcntl port F_GETFL)))
          	    (await-geteveryline! await resume
          				 port
          				 (lambda (line)
          				   (simple-format #t
          						  "The line was: ~A\n"
          						  line))))))
          (event-loop-run!)

 -- Scheme Procedure: await-getsomelines! await resume [loop] port proc
     This procedure is intended to be called within a waitable procedure
     invoked by a-sync (which supplies the 'await' and 'resume'
     arguments), and does the same as await-geteveryline!, except that
     it provides a second argument to 'proc', namely an escape
     continuation which can be invoked by 'proc' to cause the procedure
     to return before end-of-file is reached.  Behavior is identical to
     await-geteveryline!  if the continuation is not invoked.

     This procedure will apply 'proc' to every complete line of text
     received (without the terminating '\n' character).  The watch will
     not end until end-of-file or an exceptional condition ('excpt) is
     reached, which would cause this procedure to end and return an
     end-of-file object or #f respectively, or until the escape
     continuation is invoked, in which case the value passed to the
     escape continuation will be returned.  The 'loop' argument is
     optional: this procedure operates on the event loop passed in as an
     argument, or if none is passed (or #f is passed), on the default
     event loop.

     When 'proc' executes, 'await' and 'resume' will still be in use by
     this procedure, so they may not be reused by 'proc' (even though
     'proc' runs in the event loop thread).

     See the documentation on the await-read-suspendable!  procedure for
     further particulars about this procedure.

     Here is an example of the use of await-getsomelines!:
          (set-default-event-loop!) ;; if none has yet been set
          (a-sync (lambda (await resume)
          	  (display "Enter lines of text at the keyboard, enter an empty line to finish\n")
          	  (let ((port (open "/dev/tty" O_RDONLY)))
          	    (fcntl port F_SETFL (logior O_NONBLOCK
          				(fcntl port F_GETFL)))
          	    (await-getsomelines! await resume
          				 port
          				 (lambda (line k)
          				   (when (string=? line "")
          					 (k #f))
          				   (simple-format #t
          						  "The line was: ~A\n"
          						  line))))))
          (event-loop-run!)

 -- Scheme Procedure: await-getblock! await resume [loop] port size
     This procedure is provided mainly to retain compatibility with the
     guile-a-sync library for guile-2.0, because it is trivial to
     implement this kind of functionality with await-read-suspendable!
     (and is implemented by await-read-suspendable!).

     It is intended to be called within a waitable procedure invoked by
     a-sync (which supplies the 'await' and 'resume' arguments), and
     reads a block of data, such as a binary record, of size 'size' from
     a non-blocking suspendable port 'port'.  This procedure and will
     return a pair, normally comprising as its car a bytevector of
     length 'size' containing the data, and as its cdr the number of
     bytes received and placed in the bytevector (which will be the same
     as 'size' unless an end-of-file object was encountered part way
     through receiving the data).  If an exceptional condition ('excpt)
     is encountered, a pair comprising (#f .  #f) will be returned.  If
     an end-of-file object is encountered without any bytes of data, a
     pair with eof-object as car and #f as cdr will be returned.

     The 'loop' argument is optional: this procedure operates on the
     event loop passed in as an argument, or if none is passed (or #f is
     passed), on the default event loop.

     See the documentation on the await-read-suspendable!  procedure for
     further particulars about this procedure.

 -- Scheme Procedure: await-geteveryblock! await resume [loop] port size
          proc
     This procedure is provided mainly to retain compatibility with the
     guile-a-sync library for guile-2.0, because it is trivial to
     implement this kind of functionality with await-read-suspendable!
     (and is implemented by await-read-suspendable!).

     It is intended to be called within a waitable procedure invoked by
     a-sync (which supplies the 'await' and 'resume' arguments), and
     will apply 'proc' to any block of data received, such as a binary
     record.  'proc' should be a procedure taking two arguments, first a
     bytevector of length 'size' containing the block of data read and
     second the size of the block of data placed in the bytevector.  The
     value passed as the size of the block of data placed in the
     bytevector will always be the same as 'size' unless end-of-file has
     been encountered after receiving only a partial block of data.  The
     watch will not end until end-of-file or an exceptional condition
     ('excpt) is reached.  In the event of that happening, this
     procedure will end and return an end-of-file object or #f
     respectively.

     For efficiency reasons, this procedure passes its internal
     bytevector buffer to 'proc' as proc's first argument and, when
     'proc' returns, re-uses it.  Therefore, if 'proc' stores its first
     argument for use after 'proc' has returned, it should store it by
     copying it.

     The 'loop' argument is optional: this procedure operates on the
     event loop passed in as an argument, or if none is passed (or #f is
     passed), on the default event loop.

     When 'proc' executes, 'await' and 'resume' will still be in use by
     this procedure, so they may not be reused by 'proc' (even though
     'proc' runs in the event loop thread).

     See the documentation on the await-read-suspendable!  procedure for
     further particulars about this procedure.

 -- Scheme Procedure: await-getsomeblocks! await resume [loop] port size
          proc
     This procedure is intended to be called within a waitable procedure
     invoked by a-sync (which supplies the 'await' and 'resume'
     arguments), and does the same as await-geteveryblock!, except that
     it provides a third argument to 'proc', namely an escape
     continuation which can be invoked by 'proc' to cause the procedure
     to return before end-of-file is reached.  Behavior is identical to
     await-geteveryblock!  if the continuation is not invoked.

     This procedure will apply 'proc' to any block of data received,
     such as a binary record.  'proc' should be a procedure taking three
     arguments, first a bytevector of length 'size' containing the block
     of data read, second the size of the block of data placed in the
     bytevector and third an escape continuation.  The value passed as
     the size of the block of data placed in the bytevector will always
     be the same as 'size' unless end-of-file has been encountered after
     receiving only a partial block of data.  The watch will not end
     until end-of-file or an exceptional condition ('excpt) is reached,
     which would cause this procedure to end and return an end-of-file
     object or #f respectively, or until the escape continuation is
     invoked, in which case the value passed to the escape continuation
     will be returned.

     For efficiency reasons, this procedure passes its internal
     bytevector buffer to 'proc' as proc's first argument and, when
     'proc' returns, re-uses it.  Therefore, if 'proc' stores its first
     argument for use after 'proc' has returned, it should store it by
     copying it.

     The 'loop' argument is optional: this procedure operates on the
     event loop passed in as an argument, or if none is passed (or #f is
     passed), on the default event loop.

     When 'proc' executes, 'await' and 'resume' will still be in use by
     this procedure, so they may not be reused by 'proc' (even though
     'proc' runs in the event loop thread).

     See the documentation on the await-read-suspendable!  procedure for
     further particulars about this procedure.

 -- Scheme Procedure: await-write-suspendable! await resume [loop] port
          proc
     This procedure is provided to implement write file watches using
     guile-2.2/3.0's suspendable ports.  'proc' is a procedure taking a
     single argument, to which the port will be passed when it is
     invoked.  The purpose of 'proc' is to carry out i/o operations on
     'port' using the port's normal write procedures.  'port' must be a
     suspendable non-blocking port.  This procedure will return when
     'proc' returns, as if by blocking write operations.  However, the
     event loop will not be blocked by this procedure even if only
     individual characters or bytes comprising part characters can be
     written at any one time.  It is intended to be called within a
     waitable procedure invoked by a-sync (which supplies the 'await'
     and 'resume' arguments).  'proc' must not itself explicitly apply
     'await' and 'resume' as those are potentially in use by the
     suspendable port while 'proc' is executing.

     If an exceptional condition ('excpt) is encountered by the
     implementation, #f will be returned by this procedure and the write
     operations to be performed by 'proc' will be abandonned; there is
     however no guarantee that any exceptional condition that does arise
     will be encountered by the implementation - the user procedure
     'proc' may get there first and deal with it, or it may not.
     However exceptional conditions on write ports cannot normally
     occur.  In the absence of an exceptional condition, the value(s)
     returned by 'proc' will be returned ('proc' may return any number
     of values).

     The 'loop' argument is optional: this procedure operates on the
     event loop passed in as an argument, or if none is passed (or #f is
     passed), on the default event loop.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the event loop runs.

     Exceptions (say, from 'proc' because of port or conversion errors)
     will propagate out of this procedure in the first instance, and if
     not caught locally will then propagate out of event-loop-run!.

     Unlike the await-* procedures in the *note (a-sync event-loop):
     event loop. module, this procedure will not call 'await' if the
     write operation(s) in 'proc' can be effected immediately without
     waiting: instead, after writing this procedure would return
     straight away without invoking the event loop.

     As an example of how to use await-write-suspendable!, here is the
     implementation of await-put-string!:

          (define await-put-string!
            (case-lambda
              ((await resume port text) (await-put-string! await resume #f port text))
              ((await resume loop port text)
               (await-write-suspendable! await resume loop port
          			       (lambda (p)
          				 (put-string p text)
          				 ;; enforce a flush when the current
          				 ;; write-waiter is still in operation
          				 (force-output p)
          				 #t)))))

 -- Scheme Procedure: await-put-bytevector! await resume [loop] port bv
     This procedure is provided mainly to retain compatibility with the
     guile-a-sync library for guile-2.0, because it is trivial to
     implement with await-write-suspendable!  (and is implemented by
     await-write-suspendable!).

     It is intended to be called within a waitable procedure invoked by
     a-sync (which supplies the 'await' and 'resume' arguments), and
     will write the contents of bytevector 'bv' to 'port'.  The 'loop'
     argument is optional: this procedure operates on the event loop
     passed in as an argument, or if none is passed (or #f is passed),
     on the default event loop.  If an exceptional condition ('excpt) is
     encountered by the implementation, #f will be returned by this
     procedure and the write operation will be abandonned, otherwise #t
     will be returned.  However exceptional conditions on write ports
     cannot normally occur.

     The port will be flushed by this procedure upon conclusion of the
     writing of the bytevector.

     See the documentation on the await-write-suspendable!  procedure
     for further particulars about this procedure.

     As mentioned in relation to the await-write-suspendable!
     procedure, write exceptions will propagate out of this procedure in
     the first instance, and if not caught locally (say by placing a
     catch block immediately around this procedure) will then propagate
     out of event-loop-run!.  So one way of testing for EPIPE is as
     follows:
          (set-default-event-loop!) ;; if none has yet been set
          (a-sync (lambda (await resume)
          	  (catch 'system-error
          		 (lambda ()
          		   (await-put-bytevector! await resume port bv))
          		 (lambda args
          		   (if (= (system-error-errno args) EPIPE)
          		       (begin
          			 ... do something to cater for EPIPE ...)
          		       (begin
          			 ;; possibly rethrow the exception
          			 (apply throw args)))))))
          (event-loop-run!)

 -- Scheme Procedure: await-put-string! await resume [loop] port text
     This procedure is provided mainly to retain compatibility with the
     guile-a-sync library for guile-2.0, because it is trivial to
     implement with await-write-suspendable!  (and is implemented by
     await-write-suspendable!).

     It is intended to be called within a waitable procedure invoked by
     a-sync (which supplies the 'await' and 'resume' arguments), and
     will write the string 'text' to 'port'.  The 'loop' argument is
     optional: this procedure operates on the event loop passed in as an
     argument, or if none is passed (or #f is passed), on the default
     event loop.  If an exceptional condition ('excpt) is encountered by
     the implementation, #f will be returned by this procedure and the
     write operation will be abandonned, otherwise #t will be returned.
     However exceptional conditions on write ports cannot normally
     occur.

     The port will be flushed by this procedure upon conclusion of the
     writing of the string.

     If CR-LF line endings are to be written when outputting the string,
     the '\r' character (as well as the '\n' character) must be embedded
     in the string.

     See the documentation on the await-write-suspendable!  procedure
     for further particulars about this procedure.

     As mentioned in relation to the await-write-suspendable!
     procedure, write exceptions will propagate out of this procedure in
     the first instance, and if not caught locally (say by placing a
     catch block immediately around this procedure) will then propagate
     out of event-loop-run!.  So one way of testing for EPIPE is as
     follows:
          (set-default-event-loop!) ;; if none has yet been set
          (a-sync (lambda (await resume)
          	  (catch 'system-error
          		 (lambda ()
          		   (await-put-string! await resume port "test"))
          		 (lambda args
          		   (if (= (system-error-errno args) EPIPE)
          		       (begin
          			 ... do something to cater for EPIPE ...)
          		       (begin
          			 ;; possibly rethrow the exception
          			 (apply throw args)))))))
          (event-loop-run!)

     An example of the use of this procedure can also be found in the
     example-socket.scm file in the docs directory.

 -- Scheme Procedure: await-accept! await resume [loop] sock
     This procedure is provided mainly to retain compatibility with the
     guile-a-sync library for guile-2.0, because it is trivial to
     implement with await-read-suspendable!  (and is implemented by
     await-read-suspendable!).

     This procedure will start a watch on listening socket 'sock' for a
     connection.  'sock' must be a non-blocking socket port.  This
     procedure wraps the guile 'accept' procedure and therefore returns
     a pair, comprising as car a connection socket, and as cdr a socket
     address object containing particulars of the address of the remote
     connection.  The 'loop' argument is optional: this procedure
     operates on the event loop passed in as an argument, or if none is
     passed (or #f is passed), on the default event loop.  This
     procedure is intended to be called within a waitable procedure
     invoked by a-sync (which supplies the 'await' and 'resume'
     arguments).

     See the documentation on the await-read-suspendable!  procedure for
     further particulars about this procedure.

 -- Scheme Procedure: await-connect! await resume [loop] sock . args
     This procedure is provided mainly to retain compatibility with the
     guile-a-sync library for guile-2.0, because it is trivial to
     implement with await-write-suspendable!  (and is implemented by
     await-write-suspendable!).

     This procedure will connect socket 'sock' to a remote host.
     Particulars of the remote host are given by 'args' which are the
     arguments (other than 'sock') taken by guile's 'connect' procedure,
     which this procedure wraps.  'sock' must be a non-blocking socket
     port.  The 'loop' argument is optional: this procedure operates on
     the event loop passed in as an argument, or if none is passed (or
     #f is passed), on the default event loop.  This procedure is
     intended to be called within a waitable procedure invoked by a-sync
     (which supplies the 'await' and 'resume' arguments).

     There are cases where it will not be helpful to use this procedure.
     Where a connection request is immediately followed by a write to
     the remote server (say, a get request), the call to 'connect' and
     to 'put-string' can be combined in a single procedure passed to
     await-write-suspendable!.

     See the documentation on the await-write-suspendable!  procedure
     for further particulars about this procedure.


File: guile-a-sync3.info,  Node: thread pool,  Next: monotonic time,  Prev: await ports,  Up: Top

This (a-sync thread-pool) module supplements the *note (a-sync
event-loop): event loop. module.  (a-sync event-loop) provides
asynchronous procedures which can wait on the completion of a task
running in a worker thread or on an event loop running in another
thread.  However, sometimes it is better to run tasks in a thread pool
rather than launching worker threads, particularly where the workload
suits having the number of threads in the thread pool approximating to
the number of local processors available to the program.  (In guile, the
number of processors so available can be obtained using the
current-processor-count procedure.)

   This (a-sync thread-pool) module provides such a thread pool,
together with two asynchronous procedures (await-task-in-thread-pool!
and await-generator-in-thread-pool!)  which can wait in an event loop
for a task on the thread pool to complete and provide its result.

   The thread pool objects provided by this module do not make provision
for rate limiting similar to that provided by the event loops in the
*note (a-sync event-loop): event loop. module.  This is because there is
no one-size-fits-all way of doing so.  One common approach is, as in the
case of the event loops provided by this library, to apply throttling to
threads which add tasks by enforcing a wait in their thread of execution
when the level of queued tasks reaches too high a level, so hindering
their ability to add new ones.  However this is counter productive where
it is a task running on the thread pool which is adding the new tasks,
particularly with a thread pool having only a few threads running in its
pool.  Another approach is to throw an exception when adding tasks which
exceed a user-selectable level.

   The best approach is for user code to provide its own rate limiting
in cases where the way that that code is organised means that it could
produce an excessive number of accumulating unexecuted tasks in the
thread pool, possibly by applying delays when unexecuted tasks rise in
number excessively, using timeouts with an event loop.  This may be
checked for by having code call the thread-pool-get-num-tasks procedure
before adding a significant batch of new tasks in order to test queue
size, and if necessary postpone adding the new tasks until the size of
the already accumulated tasks has reduced.

   This module provides the following procedures:

 -- Scheme Procedure: make-thread-pool #:key max-threads min-threads
          idle non-blocking
     This procedure constructs a thread pool object of native OS
     threads.  It takes four optional arguments.  The #:max-thread
     keyname specifies the maximum number of threads which will run in
     the pool, and the default value is 8.  The #:min-threads keyname
     specifies the minimum number of persistent threads which will run
     in the pool and will not be subject to an #:idle timeout, and the
     default value is 0.  It is an error if #:min-threads is greater
     than #:max-threads.

     Thread pool objects with a #:min-threads setting of greater than 0
     are usually best kept as top level objects, because the minimum
     value of threads will keep alive in the pool until
     thread-pool-stop!  is called.  If such a thread pool is constructed
     within a local lexical scope, then either thread-pool-stop!  must
     be applied to the pool before that scope is exited, or the last
     task added to the pool should itself apply thread-pool-stop!  to
     the pool (which it can do if 'non-blocking' is #t).  Otherwise, the
     minimum value of threads will remain alive uselessly in blocked
     condition in the pool until the program terminates, even though the
     pool may be inaccessible.

     The #:idle keyname specifies the length of time in milliseconds
     that threads greater in number than #:min-threads and not executing
     any tasks will remain in existence.  The default is 5000 (5
     seconds).

     The #:non-blocking keyname affects the operation of the
     thread-pool-stop!  procedure.  When set to #f, which is the
     default, that procedure will not return until all tasks previously
     added to the pool have completed.  If set to #t, the
     thread-pool-stop!  procedure will return immediately, before all
     tasks have finished.

     The #:max-threads, #:non-blocking and #:idle settings may
     subsequently be altered by applying the
     thread-pool-change-max-threads!, thread-pool-set-non-blocking!  or
     thread-pool-set-idle-time!  procedure to the pool.

     This procedure will throw an exception if the system is unable to
     start the number of threads given as the #:min-threads argument.
     In such a case, any threads which have in fact started in the pool
     will be killed.

 -- Scheme Procedure: thread-pool? obj
     This procedure indicates whether 'obj' is a thread pool object
     constructed by make-thread-pool.

 -- Scheme Procedure: thread-pool-get-num-tasks pool
     This procedure returns the number of tasks which the thread pool
     object is at present either running in the pool or has queued for
     execution.  This procedure will not throw.  It is also thread safe,
     although it accesses the task number field outside the pool mutex
     and therefore with relaxed memory ordering.  That enables this
     procedure to be applied more efficiently for rate limiting purposes
     but the result might at any one time be marginally out of date.

 -- Scheme Procedure: thread-pool-get-num-threads pool
     This procedure returns the number of threads currently running in
     the thread pool.

     This procedure is thread safe (any thread may call it).

 -- Scheme Procedure: thread-pool-get-max-threads pool
     This procedure returns the current maximum number of threads set
     for the thread pool.

     This procedure is thread safe (any thread may call it).

 -- Scheme Procedure: thread-pool-change-max-threads! pool delta
     This procedure will increase, or if 'delta' is negative reduce, the
     maximum number of threads which the thread pool object will
     currently run by the value of 'delta'.  The main purpose of this is
     to enable a task to increment the maximum thread number where it is
     about to enter a call which may block (non-asynchronously) for some
     time, with a view to decrementing it later when it has finished
     making blocking calls, so as to enable another thread to keep a
     core active.  A with-thread-pool-increment macro is available which
     will do this for you automatically in an exception-safe way (see
     the documentation on that macro below).

     If 'delta' is negative and results in a max-threads value of less
     than the current number of running threads, the number of threads
     actually running will only be reduced as tasks complete, or as idle
     timeouts expire.  The maximum number of threads will not be reduced
     by this procedure below the min-threads value, or if that value is
     0, below 1.

     This procedure does nothing if thread-pool-stop!  has previously
     been called.  This procedure is thread safe - any thread may call
     it.

     If 'delta' is positive and tasks are currently queued for
     execution, a new thread or threads will be started for the queued
     tasks.  This procedure may therefore throw an exception if the
     system is unable to start the required new thread(s).  Because
     starting new threads can be time consuming, to minimize contention
     new threads are started outside the pool's mutex, although internal
     book-keeping is done within the mutex.  One consequence is that if
     such an exception is thrown while another thread has concurrently
     tried to reduce the size of the pool, the number of threads running
     in the pool may be smaller than it was when this procedure was
     called.  Where min-threads is 0, in certain circumstances after an
     exception where no new threads can be started, the pool could have
     no running threads in it (so that thread-pool-get-num-threads
     returns 0) even though some tasks previously added to the pool
     remain pending.  If the system can start no new threads even though
     none are running in the pool, it will be significantly broken so it
     is not usually worth troubling about this - the program is doomed
     in that event whatever.  However if that is wrong and the cause of
     the failure to start any threads can be addressed, then the thread
     pool can be brought back into use by calling this procedure again
     with a positive value (which can be preceded by a call with a
     negative value to prevent too many threads trying to start).

 -- Scheme Procedure: thread-pool-get-non-blocking pool
     This procedure returns the current non-blocking status of the
     thread pool.  (See the documentation on the thread-pool-stop!
     procedure for more information about what that means.)

     This procedure is thread safe (any thread may call it).

 -- Scheme Procedure: thread-pool-set-non-blocking! pool val
     This procedure sets the non-blocking status of the thread pool.  If
     'val' is #f, the thread-pool-stop procedure will block, if #t it
     will not.  (See the documentation on the thread-pool-stop!
     procedure for more information about this.)

     This procedure is thread safe (any thread may call it).

     This procedure will throw a compound &thread-pool-error exception
     (also incorporating &origin and &message objects) if it is invoked
     after the thread pool object concerned has been closed by a call to
     thread-pool-stop!.

 -- Scheme Procedure: thread-pool-get-idle-time pool
     This procedure returns the current idle time setting for the thread
     pool, in milliseconds.

     This procedure is thread safe (any thread may call it).

 -- Scheme Procedure: thread-pool-set-idle-time! pool millisecs
     This procedure sets the current idle time for the thread pool,
     namely the length of time in milliseconds that threads greater in
     number than the minimum and not executing any tasks will remain in
     existence waiting for new tasks.  This will only have effect for
     threads in the pool which begin waiting for new tasks after this
     procedure is called.

     This procedure is thread safe (any thread may call it).

 -- Scheme Procedure: thread-pool-stop! pool
     This procedure will cause the thread-pool object to stop running
     tasks.  However, all tasks already running or queued for execution
     will be permitted to execute and complete normally.  If the
     thread-pool's non-blocking setting is set to #f, this procedure
     will wait until all the tasks still to execute have finished before
     returning, and if #t it will return straight away.

     After this procedure has been called, any attempt to add further
     tasks with the thread-pool-add!  procedure will fail, and that
     procedure will throw a compound &thread-pool-error exception (also
     incorporating &origin and &message objects).  The same exception
     will be thrown if this procedure is applied to a thread pool to
     which this procedure has previously been applied.

     This procedure is thread safe (any thread may call it) unless the
     non-blocking setting is #f, in which case no task running on the
     thread-pool object may call this procedure.

 -- Scheme Procedure: thread-pool-add! pool task [fail-handler]
     This procedure adds a new task to the thread pool.  'task' must be
     a thunk.  If one or more threads in the pool are currently blocking
     and waiting for a task, then the task will begin executing
     immediately in one of the threads.  If not, and the number of
     threads running in the pool is less than the value returned by
     thread-pool-get-max-threads, a new thread will start and the task
     will execute immediately in the new thread.  Otherwise, the task
     will be queued for execution as soon as a thread becomes available.
     Tasks will begin execution in the order in which they are added to
     the thread pool object.  This procedure is thread safe (any thread
     may call it, including any task running on the thread pool object).

     An optional handler procedure may be passed to 'fail-handler' which
     will be invoked if the task throws an exception.  The
     'fail-handler' procedure will be passed the exception object which
     was thrown.  If a task throws an exception and no handler procedure
     is provided, the program will terminate.

     If this procedure starts a new thread (see above), it may throw an
     exception if the system is unable to start the thread correctly,
     and if it does so the task will not be added.  This procedure will
     throw a compound &thread-pool-error exception (also incorporating
     &origin and &message objects) if it is invoked after the thread
     pool object concerned has been closed by a call to
     thread-pool-stop!.

 -- Syntax: with-thread-pool-increment pool body0 body1 ...
     This macro is intended to be called by a task running on a thread
     pool which is about to make a blocking (non-asynchronous) call.  It
     will increment the max-threads value of 'pool' by 1 (by calling
     thread-pool-change-max-threads!)  so as to enable a queued task to
     keep a core active, and decrement it again when execution of the
     body clauses has completed.

     The (i) increment, (ii) execution of body clauses, and (iii)
     decrement, form the three branches of a dynamic-wind, so the
     decrement automatically occurs if control leaves body execution
     because of an exception or other jump.

 -- Scheme Procedure: await-task-in-thread-pool! await resume [loop]
          pool thunk [handler]
     The 'loop' argument is optional.  The procedure will run 'thunk' in
     the thread pool specified by the 'pool' argument.  The result of
     executing 'thunk' will then be posted to the event loop specified
     by the 'loop' argument, or to the default event loop if no 'loop'
     argument is provided or if #f is provided as the 'loop' argument
     (pattern matching is used to detect the type of the third
     argument), and will comprise this procedure's return value.  This
     procedure is intended to be called within a waitable procedure
     invoked by a-sync (which supplies the 'await' and 'resume'
     arguments).  It will normally be necessary to call
     event-loop-block!  on 'loop' (or on the default event loop) before
     invoking this procedure.

     If the optional 'handler' argument is provided, then that handler
     will run if 'thunk' throws, and the return value of the handler
     would become the return value of this procedure; otherwise the
     program will terminate if an unhandled exception propagates out of
     'thunk'.  'handler' should take a single argument, which will be
     the thrown exception object.  Note that unlike a handler passed to
     the thread-pool-add!  procedure, 'handler' will run in the event
     loop thread and not in a thread pool thread.  Exceptions thrown by
     the handler procedure will propagate out of event-loop-run!  for
     the 'loop' event loop.

     This procedure calls 'await' and must (like the a-sync procedure)
     be called in the same thread as that in which the 'loop' or default
     event loop runs (as the case may be).

     This procedure calls event-post!  in the 'loop' or default event
     loop, which could be subject to throttling (see the documentation
     for the make-event-loop procedure for further information).

     Exceptions may propagate out of this procedure if they arise while
     setting up, which shouldn't happen unless the thread pool given by
     the 'pool' argument has been closed (in which case a compound
     &thread-pool-error exception, also incorporating &origin and
     &message objects, will arise), the thread pool tries to start an
     additional native thread which the operating system fails to supply
     (which would cause a system exception to arise) or memory is
     exhausted.

     Here is an example of the use of await-task-in-thread-pool!:
          (set-default-event-loop!) ;; if none has yet been set
          (let ((pool (make-thread-pool #:max-threads 4)))
            (event-loop-block! #t) ;; because the task runs in another thread
            (a-sync (lambda (await resume)
          	    (simple-format #t "1 + 1 is ~A\n"
          			   (await-task-in-thread-pool! await resume
          						       pool
          						       (lambda ()
          							 (+ 1 1))))
          	    (event-loop-block! #f))))
          (event-loop-run!)

 -- Scheme Procedure: await-generator-in-thread-pool! await resume
          [loop] pool generator proc [handler]
     The loop argument is optional.  The 'generator' argument is a
     procedure taking one argument, namely a yield argument (see the
     documentation on the make-iterator procedure for further details).
     This await-generator-in-thread-pool!  procedure will cause
     'generator' to run as a task in the 'pool' thread pool, and
     whenever 'generator' yields a value this will cause 'proc' to
     execute in the event loop specified by the 'loop' argument, or in
     the default event loop if no 'loop' argument is provided or if #f
     is provided as the 'loop' argument.  'proc' should be a procedure
     taking a single argument, namely the value yielded by the
     generator.

     This procedure is intended to be called within a waitable procedure
     invoked by a-sync (which supplies the 'await' and 'resume'
     arguments).  It will normally be necessary to call
     event-loop-block!  on 'loop' (or on the default event loop) before
     invoking this procedure.

     If the optional 'handler' argument is provided, then that handler
     will run if 'generator' throws an exception; otherwise the program
     will terminate if an unhandled exception propagates out of
     'generator'.  'handler' should take a single argument, which will
     be the thrown exception object.  Note that unlike a handler passed
     to the thread-pool-add!  procedure, 'handler' will run in the event
     loop thread and not in a thread pool thread.  This procedure will
     return #f if the generator completes normally, or
     'guile-a-sync-thread-error if the generator throws an exception and
     'handler' is run (the 'guile-a-sync-thread-error symbol is reserved
     to the implementation and should not be yielded by the generator).
     Exceptions thrown by the handler procedure will propagate out of
     event-loop-run!  for the 'loop' event loop.

     This procedure calls 'await' and will return when the generator has
     finished or, if 'handler' is provided, upon the generator raising
     an exception.  This procedure must (like the a-sync procedure) be
     called in the same thread as that in which the 'loop' or default
     event loop runs (as the case may be).

     This procedure calls event-post!  in the 'loop' or default event
     loop, which could be subject to throttling (see the documentation
     for the make-event-loop procedure for further information).

     Exceptions may propagate out of this procedure if they arise while
     setting up, which shouldn't happen unless the thread pool given by
     the 'pool' argument has been closed (in which case a compound
     &thread-pool-error exception, also incorporating &origin and
     &message objects, will arise), the thread pool tries to start an
     additional native thread which the operating system fails to supply
     (which would cause a system exception to arise) or memory is
     exhausted.  Exceptions arising during the execution of 'proc', if
     not caught locally, will propagate out of event-loop-run!  for
     'loop' or the default event loop (as the case may be).

     Here is an example of the use of await-generator-in-thread-pool!:
          (set-default-event-loop!) ;; if none has yet been set
          (let ((pool (make-thread-pool #:max-threads 4)))
            (event-loop-block! #t) ;; because the generator runs in another thread
            (a-sync (lambda (await resume)
          	    (await-generator-in-thread-pool! await resume
          					     pool
          					     (lambda (yield)
          					       (let loop ((count 0))
          						 (when (< count 5)
          						   (yield (* 2 count))
          						   (loop (1+ count)))))
          					     (lambda (val)
          					       (display val)
          					       (newline)))
          	    (event-loop-block! #f))))
          (event-loop-run!)


File: guile-a-sync3.info,  Node: monotonic time,  Next: gnome glib,  Prev: thread pool,  Up: Top

The (a-sync monotonic-time) module provides two procedures.  It is
loaded by the *note (a-sync event-loop): event loop. module.

 -- Scheme Procedure: have-monotonic-time?
     This procedure indicates whether the get-time procedure (see below)
     provides a monotonic clock.  Almost all modern linux/unix-like
     systems will do so.  This procedure may return #f if windows is in
     use, or if the guile-a-sync library was cross-compiled on one
     architecture for a different one.

 -- Scheme Procedure: get-time
     This returns the current time as a (secs .  usecs) pair from some
     arbitrary epoch.  If (have-monotonic-time) returns #t, then this
     will be derived from a monotonic clock obtained by calling the
     clock_gettime() POSIX function with a CLOCK_MONOTONIC argument.
     This procedure is used by the *note event-loop: event loop. timeout
     implementation.  This procedure throws an 'a-sync-exception (which
     would propagate out of the event-loop-run!  procedure if *note
     event-loop: event loop. is in use) if the library has been
     configured for monotonic time at configuration time but it is not
     in fact supported.  However this is not worth catering for by user
     code as it should never happen - the library configuration macros
     should always give the correct answer


File: guile-a-sync3.info,  Node: gnome glib,  Next: compose,  Prev: monotonic time,  Up: Top

When using the scheme (gnome gtk) bindings of guile-gnome with guile, in
order to provide await semantics on gtk+ callbacks it will normally be
necessary to use the 'await' and 'resume' procedures provided by the
a-sync procedure in the *note (a-sync coroutines): coroutines. module
directly (calling 'resume' in the gtk+ callback when ready, and waiting
on that callback using 'await').  However when launching timeouts, file
watches or idle events on the glib main loop, convenience procedures are
possible similar to those provided for the event loop in the *note
(a-sync event-loop): event loop. module.  These are set out below.

   Note that the g-idle-add procedure in guile-gnome is suspect - there
appears to be a garbage collection issue, and if you call the procedure
often enough in a single or multi-threaded program it will eventually
segfault.  g-io-add-watch is also broken in guile-gnome, so this library
uses its own glib-add-watch procedure which is exported publicly in case
it is useful to users.

   Most of the scheme files provided by this library are by default
compiled by this library to bytecode.  That is not the case with this
module, so as not to create a hard dependency on guile-gnome.

   Including this module will automatically enable suspendable ports in
order to support the await-glib-read-suspendable,
await-glib-write-suspendable and await-glib-getline procedures.  To
disable suspendable ports again, uninstall-suspendable-ports!  can be
called, but this means that those procedures can no longer be used while
suspendable ports are disabled.  In addition, any port using those
procedures must be made non-blocking using fcntl as follows:

     (fcntl [port] F_SETFL (logior O_NONBLOCK
                           (fcntl [port] F_GETFL)))

   The (a-sync gnome-glib) module provides the following procedures:

 -- Scheme Procedure: await-glib-task-in-thread await resume thunk
          [handler]
     This is a convenience procedure which will run 'thunk' in its own
     thread, and then post an event to the default glib main loop when
     'thunk' has finished.  This procedure calls 'await' in the default
     glib main loop and will return the thunk's return value.  It is
     intended to be called in a waitable procedure invoked by a-sync.
     If the optional 'handler' argument is provided, then it will be run
     in the default glib main loop if 'thunk' throws and its return
     value will be the return value of this procedure; otherwise the
     program will terminate if an unhandled exception propagates out of
     'thunk'.  'handler' should take a single argument, which will be
     the thrown exception object.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the default glib main loop runs, where
     the result of calling 'thunk' will be received.  As mentioned
     above, the thunk itself will run in its own thread.

     Exceptions may propagate out of this procedure if they arise while
     setting up (that is, before the worker thread starts), which
     shouldn't happen unless memory is exhausted or pthread has run out
     of resources.  Exceptions arising during execution of the task, if
     not caught by a handler procedure, will terminate the program.
     Exceptions thrown by the handler procedure will propagate out of
     g-main-loop-run.

     This procedure uses g-idle-add: see the introductory remarks about
     that.

     Here is an example of the use of await-glib-task-in-thread:
          (define main-loop (g-main-loop-new #f #f))
          (a-sync (lambda (await resume)
          	  (simple-format #t "1 + 1 is ~A\n"
          			 (await-glib-task-in-thread await resume
          						    (lambda ()
          						      (+ 1 1))))
          	  (g-main-loop-quit main-loop)))
          (g-main-loop-run main-loop)

 -- Scheme Procedure: await-glib-task await resume thunk
     This is a convenience procedure for use with glib, which will run
     'thunk' in the default glib main loop.  This procedure calls
     'await' and will return the thunk's return value.  It is intended
     to be called in a waitable procedure invoked by a-sync.  It is the
     single-threaded corollary of await-glib-task-in-thread.  This means
     that (unlike with await-glib-task-in-thread) while 'thunk' is
     running other events in the main loop will not make progress, so
     blocking calls should not be made in 'thunk'.

     When 'thunk' is executed, this procedure is waiting on 'await', so
     'await' and 'resume' cannot be used again in 'thunk' (although
     'thunk' can call a-sync to start another series of asynchronous
     operations with a new await-resume pair).  For that reason,
     await-glib-yield is usually more convenient for composing
     asynchronous tasks.  In retrospect, this procedure offers little
     over await-glib-yield, apart from symmetry with
     await-glib-task-in-thread.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the default glib main loop runs.

     Exceptions may propagate out of this procedure if they arise while
     setting up (that is, before the task starts), which shouldn't
     happen unless memory is exhausted.  Exceptions arising during
     execution of the task, if not caught locally, will propagate out of
     g-main-loop-run.

     This procedure uses g-idle-add: see the introductory remarks about
     that.

     Here is an example of the use of await-glib-task:
          (define main-loop (g-main-loop-new #f #f))
          (a-sync (lambda (await resume)
          	  (simple-format #t "1 + 1 is ~A\n"
          			 (await-glib-task await resume
          					  (lambda ()
          					    (+ 1 1))))
          	  (g-main-loop-quit main-loop)))
          (g-main-loop-run main-loop)

 -- Scheme Procedure: await-glib-yield await resume
     This is a convenience procedure for use with glib, which will
     surrender execution to the default glib main loop, so that code in
     other a-sync or compose-a-sync blocks can run.  The remainder of
     the code after the call to await-glib-yield in the current a-sync
     or compose-a-sync block will execute on the next iteration through
     the loop.  It is intended to be called within a waitable procedure
     invoked by a-sync (which supplies the 'await' and 'resume'
     arguments).  It's effect is similar to calling await-glib-task with
     a task that does nothing.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the default glib main loop runs.

     This procedure should not throw any exceptions unless memory is
     exhausted.

     This procedure uses g-idle-add: see the introductory remarks about
     that.

     Here is an example of the use of await-glib-yield:
          (define main-loop (g-main-loop-new #f #f))
          (a-sync (lambda (await resume)
          	  (display "In first iteration through event loop\n")
          	  (await-glib-yield await resume)
          	  (display "In next iteration through event loop\n")))
          	  (g-main-loop-quit main-loop)))
          (g-main-loop-run main-loop)

 -- Scheme Procedure: await-glib-generator-in-thread await resume
          generator proc [handler]
     This is a convenience procedure for acting asynchronously on values
     yielded by generator procedures.  The 'generator' argument is a
     procedure taking one argument, namely a yield argument (see the
     documentation on the make-iterator procedure for further details).
     This await-glib-generator-in-thread procedure will run 'generator'
     in its own worker thread, and whenever 'generator' yields a value
     will cause 'proc' to execute in the default glib main loop.

     'proc' should be a procedure taking a single argument, namely the
     value yielded by the generator.  If the optional 'handler' argument
     is provided, then that handler will be run in the default glib main
     loop if 'generator' throws; otherwise the program will terminate if
     an unhandled exception propagates out of 'generator'.  'handler'
     should take a single argument, which will be the thrown exception
     object.

     This procedure calls 'await' and will return when the generator has
     finished or, if 'handler' is provided, upon the generator throwing
     an exception.  This procedure will return #f if the generator
     completes normally, or 'guile-a-sync-thread-error if the generator
     throws an exception and 'handler' is run (the
     'guile-a-sync-thread-error symbol is reserved to the implementation
     and should not be yielded by the generator).

     This procedure is intended to be called in a waitable procedure
     invoked by a-sync.  It must (like the a-sync procedure) be called
     in the same thread as that in which the default glib main loop
     runs.  As mentioned above, the generator itself will run in its own
     thread.

     Exceptions may propagate out of this procedure if they arise while
     setting up (that is, before the worker thread starts), which
     shouldn't happen unless memory is exhausted or pthread has run out
     of resources.  Exceptions arising during execution of the
     generator, if not caught by a handler procedure, will terminate the
     program.  Exceptions thrown by the handler procedure will propagate
     out of g-main-loop-run.  Exceptions thrown by 'proc', if not caught
     locally, will also propagate out of g-main-loop-run.

     This procedure uses g-idle-add: see the introductory remarks about
     that.

     Here is an example of the use of await-glib-generator-in-thread:
          (define main-loop (g-main-loop-new #f #f))
          (a-sync (lambda (await resume)
          	  (await-glib-generator-in-thread await resume
          					  (lambda (yield)
          					    (let loop ((count 0))
          					      (when (< count 5)
          						(yield (* 2 count))
          						(loop (1+ count)))))
          					  (lambda (val)
          					    (display val)
          					    (newline)))
          	  (g-main-loop-quit main-loop)))
          (g-main-loop-run main-loop)

 -- Scheme Procedure: await-glib-generator await resume generator proc
     This is a convenience procedure for acting asynchronously on values
     yielded by generator procedures.  The 'generator' argument is a
     procedure taking one argument, namely a yield argument (see the
     documentation on the make-iterator procedure for further details).
     This await-glib-generator procedure will run 'generator', and
     whenever 'generator' yields a value will cause 'proc' to execute in
     the default glib main loop - each time 'proc' runs it will do so as
     a separate event in the main loop and so be multi-plexed with other
     events.  'proc' should be a procedure taking a single argument,
     namely the value yielded by the generator.

     This procedure is intended to be called in a waitable procedure
     invoked by a-sync.  It is the single-threaded corollary of
     await-glib-generator-in-thread.  This means that (unlike with
     await-glib-generator-in-thread) while 'generator' is running other
     events in the main loop will not make progress, so blocking calls
     (other than to the yield procedure) should not be made in
     'generator'.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the default glib main loop runs.

     When 'proc' executes, 'await' and 'resume' will still be in use by
     this procedure, so they may not be reused by 'proc' (even though
     'proc' runs in the event loop thread).

     Exceptions may propagate out of this procedure if they arise while
     setting up (that is, before the task starts), which shouldn't
     happen unless memory is exhausted.  Exceptions arising during
     execution of the generator, if not caught locally, will propagate
     out of await-glib-generator.  Exceptions thrown by 'proc', if not
     caught locally, will propagate out of g-main-loop-run.

     This procedure uses g-idle-add: see the introductory remarks about
     that.

     Here is an example of the use of await-glib-generator:
          (define main-loop (g-main-loop-new #f #f))
          (a-sync (lambda (await resume)
          	  (await-glib-generator await resume
          				(lambda (yield)
          				  (let loop ((count 0))
          				    (when (< count 5)
          				      (yield (* 2 count))
          				      (loop (1+ count)))))
          				(lambda (val)
          				  (display val)
          				  (newline)))
          	  (g-main-loop-quit main-loop)))
          (g-main-loop-run main-loop)

 -- Scheme Procedure: await-glib-timeout await resume msecs thunk
     This is a convenience procedure for use with a glib main loop,
     which will run 'thunk' in the default glib main loop when the
     timeout expires.  This procedure calls 'await' and will return the
     thunk's return value.  It is intended to be called in a waitable
     procedure invoked by a-sync.  The timeout is single shot only - as
     soon as 'thunk' has run once and completed, the timeout will be
     removed from the event loop.

     In practice, calling await-glib-sleep may often be more convenient
     for composing asynchronous code than using this procedure.  That is
     because, when 'thunk' is executed, this procedure is waiting on
     'await', so 'await' and 'resume' cannot be used again in 'thunk'
     (although 'thunk' can call a-sync to start another series of
     asynchronous operations with a new await-resume pair).  In
     retrospect, this procedure offers little over await-glib-sleep.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the default glib main loop runs.

     Exceptions may propagate out of this procedure if they arise while
     setting up (that is, before the first call to 'await' is made),
     which shouldn't happen unless memory is exhausted.  Exceptions
     thrown by 'thunk', if not caught locally, will propagate out of
     g-main-loop-run.

     Here is an example of the use of await-glib-timeout:
          (define main-loop (g-main-loop-new #f #f))
          (a-sync (lambda (await resume)
          	  (simple-format #t
          			 "Timeout ~A\n"
          			 (await-glib-timeout await resume
          					     100
          					     (lambda ()
          					       "expired")))
          	  (g-main-loop-quit main-loop)))
          (g-main-loop-run main-loop)

 -- Scheme Procedure: await-glib-sleep await resume msecs
     This is a convenience procedure for use with a glib main loop,
     which will suspend execution of code in the current a-sync or
     compose-a-sync block for the duration of 'msecs' milliseconds.  The
     event loop will not be blocked by the sleep - instead any other
     events in the event loop (including any other a-sync or
     compose-a-sync blocks) will be serviced.  It is intended to be
     called within a waitable procedure invoked by a-sync (which
     supplies the 'await' and 'resume' arguments).

     Calling this procedure is equivalent to calling await-glib-timeout
     with a 'proc' argument comprising a lambda expression that does
     nothing.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the default glib main loop runs.

     This procedure should not throw any exceptions unless memory is
     exhausted.

     Here is an example of the use of await-glib-sleep:
          (define main-loop (g-main-loop-new #f #f))
          (a-sync (lambda (await resume)
          	  (display "Entering sleep\n")
          	  (await-glib-sleep await resume 500)
          	  (display "Timeout expired\n")
          	  (g-main-loop-quit main-loop)))
          (g-main-loop-run main-loop)

 -- Scheme Procedure: glib-add-watch ioc cond func [context]
     This procedure replaces guile-gnome's g-io-add-watch procedure,
     which won't compile.  It attaches a watch on a g-io-channel object
     to the main context provided, or if none is provided, to the
     default glib main context (the main program loop).  It returns a
     glib ID which can be passed subsequently to the g-source-remove
     procedure.  It should be possible to call this procedure in any
     thread.

     'ioc' is the g-io-condition object to which the watch is to be
     attached, and 'cond' is a list of symbols (being 'in, 'out, 'pri,
     'hup, 'err and 'nval) comprising the events for which the watch is
     established.

     'func' is executed when an event occurs, and takes two arguments:
     first the g-io-channel object to which the watch has been attached,
     and second a g-io-condition object indicating the watch condition
     which has been met (note: the interface for g-io-condition objects
     is broken in guile-gnome at present).  The watch is ended either by
     'func' returning #f, or by applying g-source-remove to the return
     value of this procedure.  Otherwise the watch will continue.

     File watches in guile-gnome are implemented using a GIOChannel
     object, and unfortunately GIOChannel support in guile-gnome is
     decaying.  The only procedure that guile-gnome provides to read
     from a GIOChannel object is g-io-channel-read-line, which does not
     work.  One is therefore usually left with having to read from a
     guile port (whose underlying file descriptor is 'fd') using guile's
     port input procedures, but this has its own difficulties, which
     means that one of the following approaches should be adopted (i)
     the port has to be unbuffered (say by using the open-file or fdopen
     procedure with the '0' mode option or the R6RS open-file-input-port
     procedure with a buffer-mode of none, or by calling setvbuf), or
     (ii) 'proc' must deal with everything in the port's buffer by
     calling drain-input, or by looping on char-ready?  before
     returning, or (iii) the port's ordinary input procedures should be
     used with suspendable ports using the await-glib-read-suspendable
     procedure.  This is because otherwise, if the port is buffered,
     once the port is read from there may be further characters in the
     buffer to be dealt with even though the GIOChannel watch does not
     trigger because there is nothing new to make the file descriptor
     ready for reading.

 -- Scheme Procedure: await-glib-read-suspendable await resume port proc
     'proc' is a procedure taking a single argument, to which the port
     will be passed when it is invoked.  The purpose of 'proc' is to
     carry out i/o operations on 'port' using the port's normal read
     procedures.  'port' must be a suspendable non-blocking port.  This
     procedure will return when 'proc' returns, as if by blocking read
     operations, with the value returned by 'proc'.  However, the glib
     main loop will not be blocked by this procedure even if only
     individual characters or bytes comprising part characters are
     available at any one time.  It is intended to be called in a
     waitable procedure invoked by a-sync (which supplies the 'await'
     and 'resume' arguments).  'proc' must not itself explicitly apply
     'await' and 'resume' as those are potentially in use by the
     suspendable port while 'proc' is executing.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the default glib main loop runs.

     Exceptions (say, from 'proc' because of port or conversion errors)
     will propagate out of this procedure in the first instance, and if
     not caught locally will then propagate out of g-main-loop-run.

     This procedure will not call 'await' if the read operation(s) in
     'proc' can be effected immediately without waiting: instead, after
     reading this procedure would return straight away without invoking
     the glib main loop.

     As an example of how to use await-glib-read-suspendable, here is
     the implementation of await-glib-getline:

          (define (await-glib-getline await resume port)
            (await-glib-read-suspendable await resume port
          			       (lambda (p)
          				 (read-line p))))

 -- Scheme Procedure: await-glib-getline await resume port
     This procedure is provided mainly to retain compatibility with the
     guile-a-sync library for guile-2.0, because it is trivial to
     implement with await-glib-read-suspendable (and is implemented by
     await-glib-read-suspendable).

     It is intended to be called in a waitable procedure invoked by
     a-sync, and reads a line of text from a non-blocking suspendable
     port and returns it (without the terminating '\n' character).  See
     the documentation on the await-glib-read-suspendable procedure for
     further particulars about this procedure.

     Here is an example of the use of await-glib-getline:
          (define main-loop (g-main-loop-new #f #f))
          (a-sync (lambda (await resume)
                    (display "Enter a line of text at the keyboard\n")
          	  (let ((port (open "/dev/tty" O_RDONLY)))
          	    (fcntl port F_SETFL (logior O_NONBLOCK
          				(fcntl port F_GETFL)))
          	    (simple-format #t
          			   "The line was: ~A\n"
          			   (await-glib-getline await resume
          					       port)))
          	  (g-main-loop-quit main-loop)))
          (g-main-loop-run main-loop)

 -- Scheme Procedure: await-glib-getblock await resume port size
     This procedure is provided mainly to retain compatibility with the
     guile-a-sync library for guile-2.0, because an implementation is
     trivial to implement with await-glib-read-suspendable (and is
     implemented by await-glib-read-suspendable).

     It is intended to be called in a waitable procedure invoked by
     a-sync, and reads a block of data, such as a binary record, of size
     'size' from a non-blocking suspendable port 'port'.  This procedure
     and will return a pair, normally comprising as its car a bytevector
     of length 'size' containing the data, and as its cdr the number of
     bytes received and placed in the bytevector (which will be the same
     as 'size' unless an end-of-file object was encountered part way
     through receiving the data).  If an end-of-file object is
     encountered without any bytes of data, a pair with eof-object as
     car and #f as cdr will be returned.

     See the documentation on the await-glib-read-suspendable procedure
     for further particulars about this procedure.

 -- Scheme Procedure: await-glib-write-suspendable await resume port
          proc
     'proc' is a procedure taking a single argument, to which the port
     will be passed when it is invoked.  The purpose of 'proc' is to
     carry out i/o operations on 'port' using the port's normal write
     procedures.  'port' must be a suspendable non-blocking port.  This
     procedure will return when 'proc' returns, as if by blocking write
     operations, with the value returned by 'proc'.  However, the glib
     main loop will not be blocked by this procedure even if only
     individual characters or bytes comprising part characters can be
     written at any one time.  It is intended to be called in a waitable
     procedure invoked by a-sync (which supplies the 'await' and
     'resume' arguments).  'proc' must not itself explicitly apply
     'await' and 'resume' as those are potentially in use by the
     suspendable port while 'proc' is executing.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the default glib main loop runs.

     Exceptions (say, from 'proc' because of port or conversion errors)
     will propagate out of this procedure in the first instance, and if
     not caught locally will then propagate out of g-main-loop-run.

     This procedure will not call 'await' if the write operation(s) in
     'proc' can be effected immediately without waiting: instead, after
     writing this procedure would return straight away without invoking
     the glib main loop.

     As an example of how to use await-glib-write-suspendable, here is
     the implementation of await-glib-put-string:

          (define (await-glib-put-string await resume port text)
            (await-glib-write-suspendable await resume port
          				(lambda (p)
          				  (put-string p text)
          				  ;; enforce a flush when the current
          				  ;; write-waiter is still in operation
          				  (force-output p))))

 -- Scheme Procedure: await-glib-put-bytevector await resume port bv
     This procedure is provided mainly to retain compatibility with the
     guile-a-sync library for guile-2.0, because it is trivial to
     implement with await-glib-write-suspendable (and is implemented by
     await-glib-write-suspendable).

     It is intended to be called in a waitable procedure invoked by
     a-sync, and will write a bytevector to the port.

     See the documentation on the await-glib-write-suspendable procedure
     for further particulars about this procedure.

     As mentioned in relation to the await-glib-write-suspendable
     procedure, write exceptions will propagate out of this procedure in
     the first instance, and if not caught locally (say by placing a
     catch block immediately around this procedure) will then propagate
     out of g-main-loop-run.  So one way of testing for EPIPE is as
     follows:
          (define main-loop (g-main-loop-new #f #f))
          (a-sync (lambda (await resume)
          	  (catch 'system-error
          		 (lambda ()
          		   (await-glib-put-bytevector await resume port bv))
          		 (lambda args
          		   (if (= (system-error-errno args) EPIPE)
          		       (begin
          			 ... do something to cater for EPIPE ...)
          		       (begin
          			 ;; possibly rethrow the exception
          			 (apply throw args)))))
          	  (g-main-loop-quit main-loop)))
          (g-main-loop-run main-loop)

 -- Scheme Procedure: await-glib-put-string await resume port text
     This procedure is provided mainly to retain compatibility with the
     guile-a-sync library for guile-2.0, because it is trivial to
     implement with await-glib-write-suspendable (and is implemented by
     await-glib-write-suspendable).

     It is intended to be called in a waitable procedure invoked by
     a-sync, and will write a string to the port.

     If CR-LF line endings are to be written when outputting the string,
     the '\r' character (as well as the '\n' character) must be embedded
     in the string.

     See the documentation on the await-glib-write-suspendable procedure
     for further particulars about this procedure.

     As mentioned in relation to the await-glib-write-suspendable
     procedure, write exceptions will propagate out of this procedure in
     the first instance, and if not caught locally (say by placing a
     catch block immediately around this procedure) will then propagate
     out of g-main-loop-run.  So one way of testing for EPIPE is as
     follows:
          (define main-loop (g-main-loop-new #f #f))
          (a-sync (lambda (await resume)
          	  (catch 'system-error
          		 (lambda ()
          		   (await-glib-put-string await resume port "test"))
          		 (lambda args
          		   (if (= (system-error-errno args) EPIPE)
          		       (begin
          			 ... do something to cater for EPIPE ...)
          		       (begin
          			 ;; possibly rethrow the exception
          			 (apply throw args)))))
          	  (g-main-loop-quit main-loop)))
          (g-main-loop-run main-loop)


File: guile-a-sync3.info,  Node: compose,  Next: meeting,  Prev: gnome glib,  Up: Top

This (a-sync compose) module provides a compose-a-sync macro interface
for the a-sync procedure provided by the *note (a-sync coroutines):
coroutines. module.

 -- Syntax: (compose-a-sync [loop] ((var await-exp0) ...) await-exp1
          await-exp2 ...)
     This module provides the compose-a-sync macro.  This does two
     things: first, it calls a-sync for you and deals with the resulting
     'await' and 'resume' procedures without exposing them, which for
     many simple uses makes a-sync easier to use; and secondly it
     enables asynchronous tasks to be more easily composed on an event
     loop with intermediate results, by using a let* type syntax (in
     fact, let* is used internally).

     The 'loop' argument of compose-a-sync is optional.  If an event
     loop constructed by make-event-loop is passed to 'loop', then that
     is the main loop on which the tasks will be composed, otherwise if
     there is no 'loop' argument given, the default main loop will be
     used.  This is followed by bindings which are optional (there need
     not be any), each of which must be initialised by an expression
     comprising the application of a 'compose-a-sync'-capable procedure,
     and following the bindings there must be a body of
     'compose-a-sync'-capable procedures executed solely for the purpose
     of asynchronous side effects (this macro does not, and cannot,
     return a value because as soon as the first await is made control
     is passed to the event loop).  As in the case of let*, unlike the
     bindings the body cannot be empty - there must be at least one
     expression comprising the application of a 'compose-a-sync'-capable
     procedure in the body.

     As in the case of let*, each 'compose-a-sync'-capable procedure
     initializing a binding can see the values of the initializations
     made prior to it.  Unlike let*, a compose-a-sync block cannot be
     nested within another compose-a-sync block unless the nested block
     is placed within a 'no-await' expression or is within a callback or
     other procedure.  Furthermore, within a compose-a-sync block, the
     result obtained from a 'compose-a-sync'-capable procedure cannot be
     passed directly as an argument to another 'compose-a-sync'-capable
     procedure: the intermediate result must be stored as the value of a
     binding in the compose-a-sync block.

     A 'compose-a-sync'-capable procedure is one which takes an 'await'
     and 'resume' procedure from a-sync as its first and second
     arguments, and (if the optional 'loop' argument of this macro is
     used) takes the event loop as its third argument, followed by such
     further arguments as it requires.  All of the await-task!,
     await-task-in-thread!, await-task-in-event-loop!, await-yield!,
     await-generator!, await-generator-in-thread!,
     await-generator-in-event-loop!, await-timeout!, await-sleep!,
     await-read-suspendable!, await-write-suspendable!, await-getline!,
     await-geteveryline!, await-getsomelines!, await-getblock!,
     await-geteveryblock!, await-getsomeblocks!, await-put-bytevector!,
     await-put-string!, await-accept!, await-connect!,
     await-task-in-thread-pool!  and await-generator-in-thread-pool!
     procedures provided by the *note (a-sync event-loop): event loop,
     *note (a-sync await-ports): await ports. and *note (a-sync
     thread-pool): thread pool. modules are 'compose-a-sync'-capable.
     In addition, to make an ordinary body of code which does not block
     (and which does not need to invoke a-sync's await procedure) usable
     by compose-a-sync, the no-await macro can be used to generate a
     'compose-a-sync'-capable procedure for it (see below).

     Each binding is initialized as if sequentially (although it is done
     asynchronously on the relevant event loop).  An initialization does
     not begin until an earlier one has completed.  In addition, each
     clause in the body is executed sequentially in turn, but does so
     asynchronously on the event loop using 'await' semantics.

     When calling a 'compose-a-sync'-capable procedure within a
     'compose-a-sync' block (including when initializing its bindings),
     the 'await' and 'yield' and event-loop arguments are not explicitly
     passed to it.  The compose-a-sync macro will do it for you.

          (set-default-event-loop!) ;; if none has yet been set
          (compose-a-sync ((keyboard ((no-await (display "Enter a line of text at the keyboard\n")
                                                (open "/dev/tty" O_RDONLY))))
          		 (ignore ((no-await (fcntl keyboard F_SETFL (logior O_NONBLOCK
          								    (fcntl keyboard F_GETFL))))))
                           (ret (await-getline! keyboard)))
          	   ((no-await (simple-format #t
          				     "The line was: ~A\n"
          				     ret))))
          (event-loop-run!)

     The await-glib-task, await-glib-task-in-thread,
     await-glib-generator, await-glib-generator-in-thread,
     await-glib-timeout, await-glib-read-suspendable,
     await-glib-write-suspendable, await-glib-getline,
     await-glib-getblock, await-glib-put-bytevector and
     await-glib-put-string procedures in the *note (a-sync gnome-glib):
     gnome glib. module also meet the 'compose-a-sync'-capable
     requirements.  Here is the same example using those procedures:

          (define main-loop (g-main-loop-new #f #f))
          (compose-a-sync ((keyboard ((no-await (display "Enter a line of text at the keyboard\n")
                                                (open "/dev/tty" O_RDONLY))))
          		 (ignore ((no-await (fcntl keyboard F_SETFL (logior O_NONBLOCK
          								    (fcntl keyboard F_GETFL))))))
                           (ret (await-glib-getline keyboard)))
          	   ((no-await (simple-format #t
          				     "The line was: ~A\n"
          				     ret)
          		      (g-main-loop-quit main-loop))))
          (g-main-loop-run main-loop)

     In addition, the meeting-send and meeting-receive procedures in the
     (a-sync meeting) module meet the 'compose-a-sync'-capable
     requirements.  Here is an example using them:

          (set-default-event-loop!) ;; if none has yet been set
          (define m1 (make-meeting))
          (compose-a-sync ((datum (meeting-receive m1)))
          		((no-await (display datum)(newline))))
          (compose-a-sync ()
          		(meeting-send m1 100))
          (event-loop-run!)

     Each block of code within a compose-a-sync block will run
     independently of (and concurrently with) code in other
     compose-a-sync blocks.  Asynchronous operations are only serialized
     within any one compose-a-sync block.  As soon as any code calls
     a-sync's 'await' procedure in a compose-a-sync block,
     compose-a-sync will return and begin executing whatever follows it,
     and further execution of the compose-a-sync block will occur within
     the event loop concerned.

     Other examples of the use of this macro are given in the
     documentation of the *note (a-sync coroutines): coroutines. module.

     This macro must (like the a-sync procedure) be called in the same
     thread as that in which the event loop runs.

 -- Syntax: (no-await body0 body1 ...)
     This macro will generate a 'compose-a-sync'-capable procedure from
     a body of code which does not block.  It can be passed to
     compose-a-sync, either for use as an initializer or as a clause in
     its body.  When used as an initializer, it evaluates to the value
     of the last expression in the 'no-await' body.

     If the body throws an exception which is not caught locally, it
     will propagate out of event-loop-run!  or g-main-loop-run, as the
     case may be.

     Here is an example of the use of no-await:

          (var ((no-await (+ a b))))


File: guile-a-sync3.info,  Node: meeting,  Next: g-golf,  Prev: compose,  Up: Top

As explained in the *note general overview: overview, each 'a-sync'
block (see *note (a-sync coroutines): coroutines.) or 'compose-a-sync'
block (see *note (a-sync compose): compose.) is a separate unit of
computation which appears within itself to proceed sequentially but
which also appears to execute concurrently with other 'a-sync' or
'compose-a-sync' blocks running on the same event loop.  Each 'a-sync'
or 'compose-a-sync' block is therefore in some sense analogous to a
thread of execution.

   This (a-sync meeting) module provides a 'meeting' type which can be
used to synchronize between such "pseudo-threads" (that is, between
a-sync or compose-a-sync blocks).  A 'meeting' object is, in terms of
communicating sequential processes, an unbuffered (synchronous) channel.
Unbuffered channels in the CSP style are a natural fit for use with
coroutines running on a single native thread (but not necessarily for
native threads running in parallel unless combined with work stealing).
They are therefore a natural fit for synchronizing the "pseudo-threads"
provided by this library.

   Some of the things that can be done by using meetings can also be
done using await-generator!.  Note also that any one meeting object is
strictly for use by "pseudo-threads" which are running on the same event
loop, and so 'ipso facto' running in the same native OS thread.  To have
other native OS threads communicate with an event-loop, use
await-task-in-thread!, await-task-in-event-loop!,
await-task-in-thread-pool!, await-generator-in-thread!,
await-generator-in-event-loop!  or await-generator-in-thread-pool!  (see
*note (a-sync event-loop): event loop. and *note (a-sync thread-pool):
thread pool.).  Having said that, some things, such as having one
"pseudo-thread" join on another "pseudo-thread", are more easily done
with meeting objects.

   A "pseudo-thread" enters a meeting by applying meeting-receive (where
it is to receive a datum at the meeting) or meeting-send (where it is to
provide the datum) to a meeting object.  Once a "pseudo-thread" enters a
meeting it cannot leave until another co-operating "pseudo-thread" also
enters the meeting so the datum exchange can take place, or until the
meeting-close procedure is applied.  Once a datum exchange has taken
place, a meeting object can be reused for making another exchange
(provided the meeting object has not been closed).

   Synchronization occurs at the moment that the exchange of the datum
takes place.  Once one of the "pseudo-threads" leaves the meeting upon
meeting-receive or meeting-send (or both) returning, all subsequent
events are unsynchronized until another datum exchange is arranged.
This means that where two "pseudo-threads" share access to objects other
than the datum exchanged and they might be mutated, one "pseudo-thread"
is guaranteed to see a value of the unexchanged shared objects which is
not earlier than the value they held at the moment of datum exchange,
but it may or may not see a later value.

   Here is an example of the use of a meeting object:

     (set-default-event-loop!) ;; if none has yet been set
     (define m1 (make-meeting))

     (a-sync (lambda (await resume)
     	  (let loop ((datum (meeting-receive await resume m1)))
     	    (when (not (eq? datum 'stop-iteration))
     	      (display datum)
     	      (newline)
     	      (loop (meeting-receive await resume m1))))))

     (a-sync (lambda (await resume)
     	  (let loop ((count 0))
     	    (if (< count 4)
     		(begin
     		  (meeting-send await resume m1 count)
     		  (loop (1+ count)))
     		(meeting-close m1)))))
     (event-loop-run!)

   See the documentation on the meeting-send and meeting-receive
procedures below for an example of multiple "pseudo-threads" sending to
or receiving from a single meeting object for fan in and fan out, and
for an example of those procedures 'selecting' on more than one meeting
object.

   The (a-sync meeting) module provides the following procedures:

 -- Scheme Procedure: make-meeting [loop]
     This procedure makes and returns a meeting object.  Meetings are
     objects on which a-sync or compose-a-sync blocks running on the
     same event loop can synchronize by one passing a datum to another.
     The 'loop' argument specifies the event loop (as constructed by
     make-event-loop in the (a-sync event-loop) module) with respect to
     which the meeting will be held: it is an error if the meeting-send
     or meeting-receive procedures are passed a different event loop as
     an argument.  The 'loop' argument is optional - if none is passed,
     or #f is passed, then the default event loop will be chosen.

     Strictly speaking this procedure can be called in any native OS
     thread, but since it carries out no synchronization of native
     threads the user would have to provide her own synchronization if
     called in other than the thread of the event loop with respect to
     which the meeting will be held; so it is best if this procedure is
     called in the thread of that event loop.

 -- Scheme Procedure: meeting? obj
     This procedure indicates whether 'obj' is a meeting object
     constructed by make-meeting.

 -- Scheme Procedure: meeting-close meeting
     This closes a meeting object.  It's purpose is to wake up any
     "pseudo-thread" (that is, any a-sync or compose-a-sync block)
     waiting in meeting-send or meeting-receive by causing either
     procedure to return with a 'stop-iteration value.

     Where that is not necessary (say, the receiver already knows how
     many items are to be sent), then this procedure does not need to be
     applied.  It is not needed in order to release resources.

 -- Scheme Procedure: meeting-ready? meeting
     This indicates whether applying meeting-send or meeting-receive (as
     the case may be) to the meeting object 'meeting' will return
     immediately: in other words, this procedure will return #t if
     another a-sync or compose-a-sync block is already waiting on the
     object or the meeting object has been closed, otherwise #f.

 -- Scheme Procedure: meeting-send await resume [loop] m0 [m1 ...] datum
     This sends a datum to a receiver which is running on the same event
     loop as the sender, via one or more meeting objects 'm0 m1 ...'.
     If no receiver is waiting for the datum, this procedure waits until
     a receiver calls meeting-receive on one of the meeting objects to
     request the datum.  If a receiver is already waiting, this
     procedure passes on the datum and returns immediately.

     The 'loop' argument is optional.  If not supplied, or #f is passed,
     this procedure will use the default event loop.  It is an error if
     this procedure is given a different event loop than the one which
     was passed to make-meeting on constructing the 'meeting' objects.

     This procedure is intended to be called within a waitable procedure
     invoked by a-sync (which supplies the 'await' and 'resume'
     arguments).

     Multiple senders may wait on a meeting object to permit fan in.
     The provided datum of each sender will be passed to a receiver (as
     and when a receiver becomes available) in the order in which this
     procedure was invoked.

     Here is an example of such a fan in:

          (set-default-event-loop!) ;; if none has yet been set
          (define m1 (make-meeting))

          (a-sync (lambda (await resume)
          	  (meeting-send await resume m1 "Hello from a-sync1")))
          (a-sync (lambda (await resume)
          	  (meeting-send await resume m1 "Hello from a-sync2")))

          (a-sync (lambda (await resume)
          	  (let next ((count 0))
          	    (when (< count 2)
          	      (display (meeting-receive await resume m1))
          	      (newline)
          	      (next (1+ count))))))
          (event-loop-run!)

     In addition, this procedure has 'select'-like behavior: multiple
     meeting objects may be passed and this procedure will send to the
     first one which becomes available to receive the datum.

     Here is an example of selecting on send (here, meeting-send will
     send to the first meeting which becomes available for receiving,
     which is m2):

          (set-default-event-loop!) ;; if none has yet been set
          (define m1 (make-meeting))
          (define m2 (make-meeting))

          (a-sync (lambda (await resume)
          	  (meeting-send await resume m1 m2 "Hello")))

          (a-sync (lambda (await resume)
          	  (simple-format #t "meeting-send says: ~a~%"
          			 (meeting-receive await resume m2))))
          (event-loop-run!)

     Once a datum exchange has taken place, the meeting object(s) can be
     reused for making another exchange (provided the meeting objects
     have not been closed).

     This procedure must be called in the native OS thread in which the
     event loop concerned runs.  To have other native OS threads
     communicate with an event-loop, use await-task-in-thread!,
     await-task-in-event-loop!, await-task-in-thread-pool!,
     await-generator-in-thread!, await-generator-in-event-loop!  or
     await-generator-in-thread-pool!.

     This procedure always returns #f unless meeting-close has been
     applied to a meeting object, in which case 'stop-iteration is
     returned.  Note that if multiple meeting objects are passed to this
     procedure and one of them is then closed, this procedure will
     return 'stop-iteration and any wait will be abandonned.  It is
     usually a bad idea to close a meeting object on which this
     procedure is waiting where this procedure is selecting on more than
     one meeting object.

 -- Scheme Procedure: meeting-receive await resume [loop] m0 [m1 ...]
     This receives a datum from a sender running on the same event loop
     as the receiver, via one or more meeting objects 'm0 m1 ...'.  If
     no sender is waiting to pass the datum, this procedure waits until
     a sender calls meeting-send on one of the meeting objects to
     provide the datum.  If a sender is already waiting, this procedure
     returns immediately with the datum supplied.

     The 'loop' argument is optional.  If not supplied, or #f is passed,
     this procedure will use the default event loop.  It is an error if
     this procedure is given a different event loop than the one which
     was passed to make-meeting on constructing the 'meeting' objects.

     This procedure is intended to be called within a waitable procedure
     invoked by a-sync (which supplies the 'await' and 'resume'
     arguments).

     Multiple receivers may wait on a meeting object to permit fan out.
     The waiting receivers will be released (as and when a sender
     provides a datum) in the order in which this procedure was invoked.

     Here is an example of such a fan out:

          (set-default-event-loop!) ;; if none has yet been set
          (define m1 (make-meeting))

          (a-sync (lambda (await resume)
          	  (display (meeting-receive await resume m1))
          	  (newline)))
          (a-sync (lambda (await resume)
          	  (display (meeting-receive await resume m1))
          	  (newline)))

          (a-sync (lambda (await resume)
          	  (let next ((count 0))
          	    (when (< count 2)
          	      (meeting-send await resume m1 count)
          	      (next (1+ count))))))
          (event-loop-run!)

     In addition, this procedure has 'select'-like behavior: multiple
     meeting objects may be passed and this procedure will receive from
     the first one which sends a datum.

     Here is an example of selecting on receive:

          (set-default-event-loop!) ;; if none has yet been set
          (define m1 (make-meeting))
          (define m2 (make-meeting))

          (a-sync (lambda (await resume)
          	  (meeting-send await resume m1 "m1")))
          (a-sync (lambda (await resume)
          	  (meeting-send await resume m2 "m2")))

          (a-sync (lambda (await resume)
          	  (let next ((count 0))
          	    (when (< count 2)
          	      (simple-format #t "Message received from ~a~%"
          			     (meeting-receive await resume m1 m2))
          	      (next (1+ count))))))
          (event-loop-run!)

     Once a datum exchange has taken place, the meeting object(s) can be
     reused for making another exchange (provided the meeting objects
     have not been closed).

     This procedure must be called in the native OS thread in which the
     event loop concerned runs.  To have other native OS threads
     communicate with an event-loop, use await-task-in-thread!,
     await-task-in-event-loop!, await-task-in-thread-pool!,
     await-generator-in-thread!, await-generator-in-event-loop!  or
     await-generator-in-thread-pool!.

     This procedure always returns the datum value supplied by
     meeting-send unless meeting-close has been applied to a meeting
     object, in which case 'stop-iteration is returned.  Note that if
     multiple meeting objects are passed to this procedure and one of
     them is then closed, this procedure will return 'stop-iteration and
     any wait will be abandonned.  It is usually a bad idea to close a
     meeting object on which this procedure is waiting where this
     procedure is selecting on more than one meeting object.


File: guile-a-sync3.info,  Node: g-golf,  Next: g-golf base,  Up: Top

* Menu:


* g-golf base::        (a-sync g-golf base) module - provides base procedures for use with g-golf
* g-golf await ports:: (a-sync g-golf await-ports) module - provides procedures for using suspendable ports with g-golf
* g-golf meeting::     (a-sync g-golf meeting) - provides for synchronization between a-sync or compose-a-sync blocks when using g-golf


File: guile-a-sync3.info,  Node: g-golf base,  Next: g-golf await ports,  Up: g-golf

When using the g-golf bindings for gtk+, in order to provide await
semantics on gtk+ callbacks it will normally be necessary to use the
'await' and 'resume' procedures provided by the a-sync procedure in the
*note (a-sync coroutines): coroutines. module directly (calling 'resume'
in the gtk+ callback when ready, and waiting on that callback using
'await').  However when launching timeouts, file watches or other events
on the glib main loop using g-golf, convenience procedures are possible
similar to those provided for the event loop in the *note (a-sync
event-loop): event loop. module.  These are set out in these (a-sync
g-golf ...)  modules.

   Most of the scheme files provided by this library are by default
compiled by this library to bytecode.  That is not the case with this
module, so as not to create a hard dependency on g-golf.

   The (a-sync g-golf base) module provides the following procedures:

 -- Scheme Procedure: await-glib-task-in-thread await resume thunk
          [handler]
     This is a convenience procedure which will run 'thunk' in its own
     thread, and then post an event to the default glib main loop when
     'thunk' has finished.  This procedure calls 'await' in the default
     glib main loop and will return the thunk's return value.  It is
     intended to be called in a waitable procedure invoked by a-sync.
     If the optional 'handler' argument is provided, then it will be run
     in the default glib main loop if 'thunk' throws and its return
     value will be the return value of this procedure; otherwise the
     program will terminate if an unhandled exception propagates out of
     'thunk'.  'handler' should take a single argument, which will be
     the thrown exception object.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the default glib main loop runs, where
     the result of calling 'thunk' will be received.  As mentioned
     above, the thunk itself will run in its own thread.

     Exceptions may propagate out of this procedure if they arise while
     setting up (that is, before the worker thread starts), which
     shouldn't happen unless memory is exhausted or pthread has run out
     of resources.  Exceptions arising during execution of the task, if
     not caught by a handler procedure, will terminate the program.
     Exceptions thrown by the handler procedure will propagate out of
     g-main-loop-run.

     Here is an example of the use of await-glib-task-in-thread:
          (define main-loop (g-main-loop-new #f #f))
          (a-sync (lambda (await resume)
          	  (simple-format #t "1 + 1 is ~A\n"
          			 (await-glib-task-in-thread await resume
          						    (lambda ()
          						      (+ 1 1))))
          	  (g-main-loop-quit main-loop)))
          (g-main-loop-run main-loop)

 -- Scheme Procedure: await-glib-task await resume thunk
     This is a convenience procedure for use with glib, which will run
     'thunk' in the default glib main loop.  This procedure calls
     'await' and will return the thunk's return value.  It is intended
     to be called in a waitable procedure invoked by a-sync.  It is the
     single-threaded corollary of await-glib-task-in-thread.  This means
     that (unlike with await-glib-task-in-thread) while 'thunk' is
     running other events in the main loop will not make progress, so
     blocking calls should not be made in 'thunk'.

     When 'thunk' is executed, this procedure is waiting on 'await', so
     'await' and 'resume' cannot be used again in 'thunk' (although
     'thunk' can call a-sync to start another series of asynchronous
     operations with a new await-resume pair).  For that reason,
     await-glib-yield is usually more convenient for composing
     asynchronous tasks.  In retrospect, this procedure offers little
     over await-glib-yield, apart from symmetry with
     await-glib-task-in-thread.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the default glib main loop runs.

     Exceptions may propagate out of this procedure if they arise while
     setting up (that is, before the task starts), which shouldn't
     happen unless memory is exhausted.  Exceptions arising during
     execution of the task, if not caught locally, will propagate out of
     g-main-loop-run.

     Here is an example of the use of await-glib-task:
          (define main-loop (g-main-loop-new #f #f))
          (a-sync (lambda (await resume)
          	  (simple-format #t "1 + 1 is ~A\n"
          			 (await-glib-task await resume
          					  (lambda ()
          					    (+ 1 1))))
          	  (g-main-loop-quit main-loop)))
          (g-main-loop-run main-loop)

 -- Scheme Procedure: await-glib-yield await resume
     This is a convenience procedure for use with glib, which will
     surrender execution to the default glib main loop, so that code in
     other a-sync or compose-a-sync blocks can run.  The remainder of
     the code after the call to await-glib-yield in the current a-sync
     or compose-a-sync block will execute on the next iteration through
     the loop.  It is intended to be called within a waitable procedure
     invoked by a-sync (which supplies the 'await' and 'resume'
     arguments).  It's effect is similar to calling await-glib-task with
     a task that does nothing.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the default glib main loop runs.

     This procedure should not throw any exceptions unless memory is
     exhausted.

     Here is an example of the use of await-glib-yield:
          (define main-loop (g-main-loop-new #f #f))
          (a-sync (lambda (await resume)
          	  (display "In first iteration through event loop\n")
          	  (await-glib-yield await resume)
          	  (display "In next iteration through event loop\n")))
          	  (g-main-loop-quit main-loop)))
          (g-main-loop-run main-loop)

 -- Scheme Procedure: await-glib-generator-in-thread await resume
          generator proc [handler]
     This is a convenience procedure for acting asynchronously on values
     yielded by generator procedures.  The 'generator' argument is a
     procedure taking one argument, namely a yield argument (see the
     documentation on the make-iterator procedure for further details).
     This await-glib-generator-in-thread procedure will run 'generator'
     in its own worker thread, and whenever 'generator' yields a value
     will cause 'proc' to execute in the default glib main loop.

     'proc' should be a procedure taking a single argument, namely the
     value yielded by the generator.  If the optional 'handler' argument
     is provided, then that handler will be run in the default glib main
     loop if 'generator' throws; otherwise the program will terminate if
     an unhandled exception propagates out of 'generator'.  'handler'
     should take a single argument, which will be the thrown exception
     object.

     This procedure calls 'await' and will return when the generator has
     finished or, if 'handler' is provided, upon the generator throwing
     an exception.  This procedure will return #f if the generator
     completes normally, or 'guile-a-sync-thread-error if the generator
     throws an exception and 'handler' is run (the
     'guile-a-sync-thread-error symbol is reserved to the implementation
     and should not be yielded by the generator).

     This procedure is intended to be called in a waitable procedure
     invoked by a-sync.  It must (like the a-sync procedure) be called
     in the same thread as that in which the default glib main loop
     runs.  As mentioned above, the generator itself will run in its own
     thread.

     Exceptions may propagate out of this procedure if they arise while
     setting up (that is, before the worker thread starts), which
     shouldn't happen unless memory is exhausted or pthread has run out
     of resources.  Exceptions arising during execution of the
     generator, if not caught by a handler procedure, will terminate the
     program.  Exceptions thrown by the handler procedure will propagate
     out of g-main-loop-run.  Exceptions thrown by 'proc', if not caught
     locally, will also propagate out of g-main-loop-run.

     Here is an example of the use of await-glib-generator-in-thread:
          (define main-loop (g-main-loop-new #f #f))
          (a-sync (lambda (await resume)
          	  (await-glib-generator-in-thread await resume
          					  (lambda (yield)
          					    (let loop ((count 0))
          					      (when (< count 5)
          						(yield (* 2 count))
          						(loop (1+ count)))))
          					  (lambda (val)
          					    (display val)
          					    (newline)))
          	  (g-main-loop-quit main-loop)))
          (g-main-loop-run main-loop)

 -- Scheme Procedure: await-glib-generator await resume generator proc
     This is a convenience procedure for acting asynchronously on values
     yielded by generator procedures.  The 'generator' argument is a
     procedure taking one argument, namely a yield argument (see the
     documentation on the make-iterator procedure for further details).
     This await-glib-generator procedure will run 'generator', and
     whenever 'generator' yields a value will cause 'proc' to execute in
     the default glib main loop - each time 'proc' runs it will do so as
     a separate event in the main loop and so be multi-plexed with other
     events.  'proc' should be a procedure taking a single argument,
     namely the value yielded by the generator.

     This procedure is intended to be called in a waitable procedure
     invoked by a-sync.  It is the single-threaded corollary of
     await-glib-generator-in-thread.  This means that (unlike with
     await-glib-generator-in-thread) while 'generator' is running other
     events in the main loop will not make progress, so blocking calls
     (other than to the yield procedure) should not be made in
     'generator'.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the default glib main loop runs.

     When 'proc' executes, 'await' and 'resume' will still be in use by
     this procedure, so they may not be reused by 'proc' (even though
     'proc' runs in the event loop thread).

     Exceptions may propagate out of this procedure if they arise while
     setting up (that is, before the task starts), which shouldn't
     happen unless memory is exhausted.  Exceptions arising during
     execution of the generator, if not caught locally, will propagate
     out of await-glib-generator.  Exceptions thrown by 'proc', if not
     caught locally, will propagate out of g-main-loop-run.

     Here is an example of the use of await-glib-generator:
          (define main-loop (g-main-loop-new #f #f))
          (a-sync (lambda (await resume)
          	  (await-glib-generator await resume
          				(lambda (yield)
          				  (let loop ((count 0))
          				    (when (< count 5)
          				      (yield (* 2 count))
          				      (loop (1+ count)))))
          				(lambda (val)
          				  (display val)
          				  (newline)))
          	  (g-main-loop-quit main-loop)))
          (g-main-loop-run main-loop)

 -- Scheme Procedure: await-glib-timeout await resume msecs thunk
     This is a convenience procedure for use with a glib main loop,
     which will run 'thunk' in the default glib main loop when the
     timeout expires.  This procedure calls 'await' and will return the
     thunk's return value.  It is intended to be called in a waitable
     procedure invoked by a-sync.  The timeout is single shot only - as
     soon as 'thunk' has run once and completed, the timeout will be
     removed from the event loop.

     In practice, calling await-glib-sleep may often be more convenient
     for composing asynchronous code than using this procedure.  That is
     because, when 'thunk' is executed, this procedure is waiting on
     'await', so 'await' and 'resume' cannot be used again in 'thunk'
     (although 'thunk' can call a-sync to start another series of
     asynchronous operations with a new await-resume pair).  In
     retrospect, this procedure offers little over await-glib-sleep.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the default glib main loop runs.

     Exceptions may propagate out of this procedure if they arise while
     setting up (that is, before the first call to 'await' is made),
     which shouldn't happen unless memory is exhausted.  Exceptions
     thrown by 'thunk', if not caught locally, will propagate out of
     g-main-loop-run.

     Here is an example of the use of await-glib-timeout:
          (define main-loop (g-main-loop-new #f #f))
          (a-sync (lambda (await resume)
          	  (simple-format #t
          			 "Timeout ~A\n"
          			 (await-glib-timeout await resume
          					     100
          					     (lambda ()
          					       "expired")))
          	  (g-main-loop-quit main-loop)))
          (g-main-loop-run main-loop)

 -- Scheme Procedure: await-glib-sleep await resume msecs
     This is a convenience procedure for use with a glib main loop,
     which will suspend execution of code in the current a-sync or
     compose-a-sync block for the duration of 'msecs' milliseconds.  The
     event loop will not be blocked by the sleep - instead any other
     events in the event loop (including any other a-sync or
     compose-a-sync blocks) will be serviced.  It is intended to be
     called within a waitable procedure invoked by a-sync (which
     supplies the 'await' and 'resume' arguments).

     Calling this procedure is equivalent to calling await-glib-timeout
     with a 'proc' argument comprising a lambda expression that does
     nothing.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the default glib main loop runs.

     This procedure should not throw any exceptions unless memory is
     exhausted.

     Here is an example of the use of await-glib-sleep:
          (define main-loop (g-main-loop-new #f #f))
          (a-sync (lambda (await resume)
          	  (display "Entering sleep\n")
          	  (await-glib-sleep await resume 500)
          	  (display "Timeout expired\n")
          	  (g-main-loop-quit main-loop)))
          (g-main-loop-run main-loop)

 -- Scheme Procedure: await-glib-task-in-thread-pool await resume pool
          thunk [handler]
     This is a convenience procedure for use with a glib main loop,
     which will run 'thunk' in the thread pool specified by the 'pool'
     argument (see *note (a-sync thread-pool): thread pool.).  The
     result of executing 'thunk' will then be posted to the default glib
     main loop, and will comprise this procedure's return value.  This
     procedure is intended to be called within a waitable procedure
     invoked by a-sync (which supplies the 'await' and 'resume'
     arguments).

     If the optional 'handler' argument is provided, then that handler
     will run if 'thunk' throws, and the return value of the handler
     would become the return value of this procedure; otherwise the
     program will terminate if an unhandled exception propagates out of
     'thunk'.  'handler' should take a single argument, which will be
     the thrown exception object.  Note that unlike a handler passed to
     the thread-pool-add!  procedure, 'handler' will run in the default
     glib main loop thread and not in a thread pool thread.  Exceptions
     thrown by the handler procedure will propagate out of
     g-main-loop-run.

     This procedure calls 'await' and must (like the a-sync procedure)
     be called in the same thread as that in which the default glib main
     loop runs.

     Exceptions may propagate out of this procedure if they arise while
     setting up, which shouldn't happen unless the thread pool given by
     the 'pool' argument has been closed (in which case a compound
     &thread-pool-error exception, also incorporating &origin and
     &message objects, will arise), the thread pool tries to start an
     additional native thread which the operating system fails to supply
     (which would cause a system exception to arise) or memory is
     exhausted.

     Here is an example of the use of await-glib-task-in-thread-pool:
          (define main-loop (g-main-loop-new #f #f))
          (let ((pool (make-thread-pool #:max-threads 4)))
            (a-sync (lambda (await resume)
          	    (simple-format #t "1 + 1 is ~A\n"
          			   (await-glib-task-in-thread-pool await resume
          							   pool
          							   (lambda ()
          							     (+ 1 1))))
          	    (g-main-loop-quit main-loop))))
          (g-main-loop-run main-loop)

 -- Scheme Procedure: await-glib-generator-in-thread-pool await resume
          pool generator proc [handler]
     The 'generator' argument is a procedure taking one argument, namely
     a yield argument (see the documentation on the make-iterator
     procedure for further details).  This
     await-glib-generator-in-thread-pool procedure will cause
     'generator' to run as a task in the 'pool' thread pool (see *note
     (a-sync thread-pool): thread pool.), and whenever 'generator'
     yields a value this will cause 'proc' to execute in the default
     glib main loop.  'proc' should be a procedure taking a single
     argument, namely the value yielded by the generator.

     This procedure is intended to be called within a waitable procedure
     invoked by a-sync (which supplies the 'await' and 'resume'
     arguments).

     If the optional 'handler' argument is provided, then that handler
     will run if 'generator' throws an exception; otherwise the program
     will terminate if an unhandled exception propagates out of
     'generator'.  'handler' should take a single argument, which will
     be the thrown exception object.  Note that unlike a handler passed
     to the thread-pool-add!  procedure, 'handler' will run in the
     default glib main loop thread and not in a thread pool thread.
     This procedure will return #f if the generator completes normally,
     or 'guile-a-sync-thread-error if the generator throws an exception
     and 'handler' is run (the 'guile-a-sync-thread-error symbol is
     reserved to the implementation and should not be yielded by the
     generator).  Exceptions thrown by the handler procedure will
     propagate out of g-main-loop-run.

     This procedure calls 'await' and will return when the generator has
     finished or, if 'handler' is provided, upon the generator raising
     an exception.  This procedure must (like the a-sync procedure) be
     called in the same thread as that in which the default glib main
     loop runs.

     Exceptions may propagate out of this procedure if they arise while
     setting up, which shouldn't happen unless the thread loop given by
     the 'pool' argument has been closed (in which case a compound
     &thread-pool-error exception, also incorporating &origin and
     &message objects, will arise), the thread pool tries to start an
     additional native thread which the operating system fails to supply
     (which would cause a system exception to arise) or memory is
     exhausted.  Exceptions arising during the execution of 'proc', if
     not caught locally, will propagate out of g-main-loop-run.

     Here is an example of the use of
     await-glib-generator-in-thread-pool:
          (define main-loop (g-main-loop-new #f #f))
          (let ((pool (make-thread-pool #:max-threads 4)))
            (event-loop-block! #t) ;; because the generator runs in another thread
            (a-sync (lambda (await resume)
          	    (await-glib-generator-in-thread-pool await resume
          						 pool
          						 (lambda (yield)
          						   (let loop ((count 0))
          						     (when (< count 5)
          						       (yield (* 2 count))
          						       (loop (1+ count)))))
          						 (lambda (val)
          						   (display val)
          						   (newline)))
          	    (g-main-loop-quit main-loop))))
          (g-main-loop-run main-loop)


File: guile-a-sync3.info,  Node: g-golf await ports,  Next: g-golf meeting,  Prev: g-golf base,  Up: g-golf

Most of the scheme files provided by this library are by default
compiled by this library to bytecode.  That is not the case with this
module, so as not to create a hard dependency on g-golf.

   Including this module will automatically enable suspendable ports.
To disable suspendable ports again, uninstall-suspendable-ports!  can be
called, but this means that those procedures can no longer be used while
suspendable ports are disabled.  In addition, any port using those
procedures must be made non-blocking using fcntl as follows:

     (fcntl [port] F_SETFL (logior O_NONBLOCK
                           (fcntl [port] F_GETFL)))

   The (a-sync g-golf await-ports) module provides the following
procedures:

 -- Scheme Procedure: await-glib-read-suspendable await resume port proc
     'proc' is a procedure taking a single argument, to which the port
     will be passed when it is invoked.  The purpose of 'proc' is to
     carry out i/o operations on 'port' using the port's normal read
     procedures.  'port' must be a suspendable non-blocking port.  This
     procedure will return when 'proc' returns, as if by blocking read
     operations, with the value returned by 'proc'.  However, the glib
     main loop will not be blocked by this procedure even if only
     individual characters or bytes comprising part characters are
     available at any one time.  It is intended to be called in a
     waitable procedure invoked by a-sync (which supplies the 'await'
     and 'resume' arguments).  'proc' must not itself explicitly apply
     'await' and 'resume' as those are potentially in use by the
     suspendable port while 'proc' is executing.

     If an exceptional condition ('pri) is encountered by the
     implementation, #f will be returned by this procedure and the read
     operations to be performed by 'proc' will be abandonned; there is
     however no guarantee that any exceptional condition that does arise
     will be encountered by the implementation - the user procedure
     'proc' may get there first and deal with it, or it may not.
     However exceptional conditions are very rare, usually comprising
     only out-of-band data on a TCP socket, or a pseudoterminal master
     in packet mode seeing state change in a slave.  In the absence of
     an exceptional condition, the value(s) returned by 'proc' will be
     returned.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the default glib main loop runs.

     Exceptions (say, from 'proc' because of port or conversion errors)
     will propagate out of this procedure in the first instance, and if
     not caught locally will then propagate out of g-main-loop-run.

     Unlike the await-* procedures in the (a-sync g-golf base) module,
     this procedure will not call 'await' if the read operation(s) in
     'proc' can be effected immediately without waiting: instead, after
     reading this procedure would return straight away without invoking
     the glib main loop.

     As an example of how to use await-glib-read-suspendable, here is
     the implementation of await-glib-getline:

          (define (await-glib-getline await resume port)
            (await-glib-read-suspendable await resume port
          			       (lambda (p)
          				 (read-line p))))

 -- Scheme Procedure: await-glib-getline await resume port
     This procedure is provided mainly to retain compatibility with the
     guile-a-sync library for guile-2.0, because it is trivial to
     implement with await-glib-read-suspendable (and is implemented by
     await-glib-read-suspendable).

     It is intended to be called in a waitable procedure invoked by
     a-sync, and reads a line of text from a non-blocking suspendable
     port and returns it (without the terminating '\n' character).  See
     the documentation on the await-glib-read-suspendable procedure for
     further particulars about this procedure.

     Here is an example of the use of await-glib-getline:
          (define main-loop (g-main-loop-new #f #f))
          (a-sync (lambda (await resume)
                    (display "Enter a line of text at the keyboard\n")
          	  (let ((port (open "/dev/tty" O_RDONLY)))
          	    (fcntl port F_SETFL (logior O_NONBLOCK
          					(fcntl port F_GETFL)))
          	    (simple-format #t
          			   "The line was: ~A\n"
          			   (await-glib-getline await resume
          					       port)))
          	  (g-main-loop-quit main-loop)))
          (g-main-loop-run main-loop)

 -- Scheme Procedure: await-glib-geteveryline await resume port proc
     This procedure is provided mainly to retain compatibility with the
     guile-a-sync library for guile-2.0, because it is trivial to
     implement with await-glib-read-suspendable (and is implemented by
     await-glib-read-suspendable).

     It is intended to be called within a waitable procedure invoked by
     a-sync (which supplies the 'await' and 'resume' arguments), and
     will apply 'proc' to every complete line of text received (without
     the terminating '\n' character).  The watch will not end until
     end-of-file or an exceptional condition ('pri) is reached.  In the
     event of that happening, this procedure will end and return an
     end-of-file object or #f respectively.

     When 'proc' executes, 'await' and 'resume' will still be in use by
     this procedure, so they may not be reused by 'proc' (even though
     'proc' runs in the event loop thread).

     See the documentation on the await-glib-read-suspendable procedure
     for further particulars about this procedure.

     Here is an example of the use of await-glib-geteveryline (because
     the keyboard has no end-of-file, use Ctrl-C to exit this code
     snippet):
          (define main-loop (g-main-loop-new #f #f))
          (a-sync (lambda (await resume)
          	  (display "Enter lines of text at the keyboard, ^C to finish\n")
          	  (let ((port (open "/dev/tty" O_RDONLY)))
          	    (fcntl port F_SETFL (logior O_NONBLOCK
          					(fcntl port F_GETFL)))
          	    (await-glib-geteveryline await resume
          				     port
          				     (lambda (line)
          				       (simple-format #t
          						      "The line was: ~A\n"
          						      line))))
          	  (g-main-loop-quit main-loop)))
          (g-main-loop-run main-loop)

 -- Scheme Procedure: await-glib-getsomelines await resume port proc
     This procedure is intended to be called within a waitable procedure
     invoked by a-sync (which supplies the 'await' and 'resume'
     arguments), and does the same as await-glib-geteveryline, except
     that it provides a second argument to 'proc', namely an escape
     continuation which can be invoked by 'proc' to cause the procedure
     to return before end-of-file is reached.  Behavior is identical to
     await-glib-geteveryline if the continuation is not invoked.

     This procedure will apply 'proc' to every complete line of text
     received (without the terminating '\n' character).  The watch will
     not end until end-of-file or an exceptional condition ('pri) is
     reached, which would cause this procedure to end and return an
     end-of-file object or #f respectively, or until the escape
     continuation is invoked, in which case the value passed to the
     escape continuation will be returned.

     When 'proc' executes, 'await' and 'resume' will still be in use by
     this procedure, so they may not be reused by 'proc' (even though
     'proc' runs in the event loop thread).

     See the documentation on the await-glib-read-suspendable procedure
     for further particulars about this procedure.

     Here is an example of the use of await-glib-getsomelines:
          (define main-loop (g-main-loop-new #f #f))
          (a-sync (lambda (await resume)
          	  (display "Enter lines of text at the keyboard, enter an empty line to finish\n")
          	  (let ((port (open "/dev/tty" O_RDONLY)))
          	    (fcntl port F_SETFL (logior O_NONBLOCK
          					(fcntl port F_GETFL)))
          	    (await-glib-getsomelines await resume
          				     port
          				     (lambda (line k)
          				       (when (string=? line "")
          					 (k #f))
          				       (simple-format #t
          						      "The line was: ~A\n"
          						      line))))
          	  (g-main-loop-quit main-loop)))
          (g-main-loop-run main-loop)

 -- Scheme Procedure: await-glib-getblock await resume port size
     This procedure is provided mainly to retain compatibility with the
     guile-a-sync library for guile-2.0, because an implementation is
     trivial to implement with await-glib-read-suspendable (and is
     implemented by await-glib-read-suspendable).

     It is intended to be called in a waitable procedure invoked by
     a-sync, and reads a block of data, such as a binary record, of size
     'size' from a non-blocking suspendable port 'port'.  This procedure
     will return a pair, normally comprising as its car a bytevector of
     length 'size' containing the data, and as its cdr the number of
     bytes received and placed in the bytevector (which will be the same
     as 'size' unless an end-of-file object was encountered part way
     through receiving the data).  If an end-of-file object is
     encountered without any bytes of data, a pair with eof-object as
     car and #f as cdr will be returned.

     See the documentation on the await-glib-read-suspendable procedure
     for further particulars about this procedure.

 -- Scheme Procedure: await-glib-geteveryblock await resume port size
          proc
     This procedure is provided mainly to retain compatibility with the
     guile-a-sync library for guile-2.0, because it is trivial to
     implement this kind of functionality with
     await-glib-read-suspendable (and is implemented by
     await-glib-read-suspendable).

     It is intended to be called within a waitable procedure invoked by
     a-sync (which supplies the 'await' and 'resume' arguments), and
     will apply 'proc' to any block of data received, such as a binary
     record.  'proc' should be a procedure taking two arguments, first a
     bytevector of length 'size' containing the block of data read and
     second the size of the block of data placed in the bytevector.  The
     value passed as the size of the block of data placed in the
     bytevector will always be the same as 'size' unless end-of-file has
     been encountered after receiving only a partial block of data.  The
     watch will not end until end-of-file or an exceptional condition
     ('pri) is reached.  In the event of that happening, this procedure
     will end and return an end-of-file object or #f respectively.

     For efficiency reasons, this procedure passes its internal
     bytevector buffer to 'proc' as proc's first argument and, when
     'proc' returns, re-uses it.  Therefore, if 'proc' stores its first
     argument for use after 'proc' has returned, it should store it by
     copying it.

     When 'proc' executes, 'await' and 'resume' will still be in use by
     this procedure, so they may not be reused by 'proc' (even though
     'proc' runs in the event loop thread).

     See the documentation on the await-glib-read-suspendable procedure
     for further particulars about this procedure.

 -- Scheme Procedure: await-glib-getsomeblocks await resume port size
          proc
     This procedure is intended to be called within a waitable procedure
     invoked by a-sync (which supplies the 'await' and 'resume'
     arguments), and does the same as await-glib-geteveryblock, except
     that it provides a third argument to 'proc', namely an escape
     continuation which can be invoked by 'proc' to cause the procedure
     to return before end-of-file is reached.  Behavior is identical to
     await-glib-geteveryblock if the continuation is not invoked.

     This procedure will apply 'proc' to any block of data received,
     such as a binary record.  'proc' should be a procedure taking three
     arguments, first a bytevector of length 'size' containing the block
     of data read, second the size of the block of data placed in the
     bytevector and third an escape continuation.  The value passed as
     the size of the block of data placed in the bytevector will always
     be the same as 'size' unless end-of-file has been encountered after
     receiving only a partial block of data.  The watch will not end
     until end-of-file or an exceptional condition ('pri) is reached,
     which would cause this procedure to end and return an end-of-file
     object or #f respectively, or until the escape continuation is
     invoked, in which case the value passed to the escape continuation
     will be returned.

     For efficiency reasons, this procedure passes its internal
     bytevector buffer to 'proc' as proc's first argument and, when
     'proc' returns, re-uses it.  Therefore, if 'proc' stores its first
     argument for use after 'proc' has returned, it should store it by
     copying it.

     When 'proc' executes, 'await' and 'resume' will still be in use by
     this procedure, so they may not be reused by 'proc' (even though
     'proc' runs in the event loop thread).

     See the documentation on the await-glib-read-suspendable procedure
     for further particulars about this procedure.

 -- Scheme Procedure: await-glib-write-suspendable await resume port
          proc
     'proc' is a procedure taking a single argument, to which the port
     will be passed when it is invoked.  The purpose of 'proc' is to
     carry out i/o operations on 'port' using the port's normal write
     procedures.  'port' must be a suspendable non-blocking port.  This
     procedure will return when 'proc' returns, as if by blocking write
     operations, with the value(s) returned by 'proc'.  However, the
     glib main loop will not be blocked by this procedure even if only
     individual characters or bytes comprising part characters can be
     written at any one time.  It is intended to be called in a waitable
     procedure invoked by a-sync (which supplies the 'await' and
     'resume' arguments).  'proc' must not itself explicitly apply
     'await' and 'resume' as those are potentially in use by the
     suspendable port while 'proc' is executing.

     This procedure must (like the a-sync procedure) be called in the
     same thread as that in which the default glib main loop runs.

     Exceptions (say, from 'proc' because of port or conversion errors)
     will propagate out of this procedure in the first instance, and if
     not caught locally will then propagate out of g-main-loop-run.

     Unlike the await-* procedures in the (a-sync g-golf base) module,
     this procedure will not call 'await' if the write operation(s) in
     'proc' can be effected immediately without waiting: instead, after
     writing this procedure would return straight away without invoking
     the glib main loop.

     As an example of how to use await-glib-write-suspendable, here is
     the implementation of await-glib-put-string:

          (define (await-glib-put-string await resume port text)
            (await-glib-write-suspendable await resume port
          				(lambda (p)
          				  (put-string p text)
          				  ;; enforce a flush when the current
          				  ;; write-waiter is still in
          				  ;; operation
          				  (force-output p))))

 -- Scheme Procedure: await-glib-put-bytevector await resume port bv
     This procedure is provided mainly to retain compatibility with the
     guile-a-sync library for guile-2.0, because it is trivial to
     implement with await-glib-write-suspendable (and is implemented by
     await-glib-write-suspendable).

     It is intended to be called in a waitable procedure invoked by
     a-sync, and will write a bytevector to the port.

     See the documentation on the await-glib-write-suspendable procedure
     for further particulars about this procedure.

     As mentioned in relation to the await-glib-write-suspendable
     procedure, write exceptions will propagate out of this procedure in
     the first instance, and if not caught locally (say by placing a
     catch block immediately around this procedure) will then propagate
     out of g-main-loop-run.  So one way of testing for EPIPE is as
     follows:
          (define main-loop (g-main-loop-new #f #f))
          (a-sync (lambda (await resume)
          	  (catch 'system-error
          		 (lambda ()
          		   (await-glib-put-bytevector await resume port bv))
          		 (lambda args
          		   (if (= (system-error-errno args) EPIPE)
          		       (begin
          			 ... do something to cater for EPIPE ...)
          		       (begin
          			 ;; possibly rethrow the exception
          			 (apply throw args)))))
          	  (g-main-loop-quit main-loop)))
          (g-main-loop-run main-loop)

 -- Scheme Procedure: await-glib-put-string await resume port text
     This procedure is provided mainly to retain compatibility with the
     guile-a-sync library for guile-2.0, because it is trivial to
     implement with await-glib-write-suspendable (and is implemented by
     await-glib-write-suspendable).

     It is intended to be called in a waitable procedure invoked by
     a-sync, and will write a string to the port.

     If CR-LF line endings are to be written when outputting the string,
     the '\r' character (as well as the '\n' character) must be embedded
     in the string.

     See the documentation on the await-glib-write-suspendable procedure
     for further particulars about this procedure.

     As mentioned in relation to the await-glib-write-suspendable
     procedure, write exceptions will propagate out of this procedure in
     the first instance, and if not caught locally (say by placing a
     catch block immediately around this procedure) will then propagate
     out of g-main-loop-run.  So one way of testing for EPIPE is as
     follows:
          (define main-loop (g-main-loop-new #f #f))
          (a-sync (lambda (await resume)
          	  (catch 'system-error
          		 (lambda ()
          		   (await-glib-put-string await resume port "test"))
          		 (lambda args
          		   (if (= (system-error-errno args) EPIPE)
          		       (begin
          			 ... do something to cater for EPIPE ...)
          		       (begin
          			 ;; possibly rethrow the exception
          			 (apply throw args)))))
          	  (g-main-loop-quit main-loop)))
          (g-main-loop-run main-loop)

 -- Scheme Procedure: await-glib-accept await resume sock
     This procedure is provided mainly to retain compatibility with the
     guile-a-sync library for guile-2.0, because it is trivial to
     implement with await-glib-read-suspendable (and is implemented by
     await-glib-read-suspendable).

     This procedure will start a watch on listening socket 'sock' for a
     connection.  'sock' must be a non-blocking socket port.  This
     procedure wraps the guile 'accept' procedure and therefore returns
     a pair, comprising as car a connection socket, and as cdr a socket
     address object containing particulars of the address of the remote
     connection.  This procedure is intended to be called within a
     waitable procedure invoked by a-sync (which supplies the 'await'
     and 'resume' arguments).

     See the documentation on the await-glib-read-suspendable procedure
     for further particulars about this procedure.

 -- Scheme Procedure: await-glib-connect await resume sock . args
     This procedure is provided mainly to retain compatibility with the
     guile-a-sync library for guile-2.0, because it is trivial to
     implement with await-glib-write-suspendable (and is implemented by
     await-glib-write-suspendable).

     This procedure will connect socket 'sock' to a remote host.
     Particulars of the remote host are given by 'args' which are the
     arguments (other than 'sock') taken by guile's 'connect' procedure,
     which this procedure wraps.  'sock' must be a non-blocking socket
     port.  This procedure is intended to be called in a waitable
     procedure invoked by a-sync (which supplies the 'await' and
     'resume' arguments).

     There are cases where it will not be helpful to use this procedure.
     Where a connection request is immediately followed by a write to
     the remote server (say, a get request), the call to 'connect' and
     to 'put-string' can be combined in a single procedure passed to
     await-glib-write-suspendable.

     See the documentation on the await-glib-write-suspendable procedure
     for further particulars about this procedure.


File: guile-a-sync3.info,  Node: g-golf meeting,  Prev: g-golf await ports,  Up: g-golf

As explained in the *note general overview: overview, each 'a-sync'
block (see *note (a-sync coroutines): coroutines.) or 'compose-a-sync'
block (see *note (a-sync compose): compose.) is a separate unit of
computation which appears within itself to proceed sequentially but
which also appears to execute concurrently with other 'a-sync' or
'compose-a-sync' blocks running on the same event loop.  Each 'a-sync'
or 'compose-a-sync' block is therefore in some sense analogous to a
thread of execution.

   This (a-sync g-golf meeting) module provides a 'glib-meeting' type
which can be used to synchronize between such "pseudo-threads" (that is,
between a-sync or compose-a-sync blocks) running on the default glib
main loop.  A 'glib-meeting' object is, in terms of communicating
sequential processes, an unbuffered (synchronous) channel.  Unbuffered
channels in the CSP style are a natural fit for use with coroutines
running on a single native thread (but not necessarily for native
threads running in parallel unless combined with work stealing).  They
are therefore a natural fit for synchronizing the "pseudo-threads"
provided by this library.

   Look at the *note (a-sync meeting): meeting. documentation for
examples of the use of meeting objects and how and when synchronization
takes place, which applies also to glib-meeting objects: this is not
repeated again here, save to translate the parallel-map example to
glib-meeting form:

     (use-modules (a-sync g-golf base)
     	     (a-sync g-golf meeting)
     	     (a-sync coroutines)
     	     (a-sync compose)
     	     (g-golf glib main-event-loop)
     	     (ice-9 match))

     (define main-loop (g-main-loop-new #f #f))

     (define (parallel-map await resume proc lst)
       (match lst
         (() '())
         ((head . tail)
          (let ((m1 (make-glib-meeting)))
            (compose-a-sync ((hd (await-glib-task-in-thread (lambda () (proc head)))))
     		       (glib-meeting-send m1 hd))
            (let* ((tl (parallel-map await resume proc tail))
     	      (hd (glib-meeting-receive await resume m1)))
     	 (cons hd tl))))))

     ;; simulate a computational task which takes 1 second to complete
     (define (do-work i) (sleep 1) (* i 2))

     (a-sync
      (lambda (await resume)
        (let ((lst (parallel-map await resume do-work (list 1 2 3 4 5))))
          (display lst)(newline)
          (g-main-loop-quit main-loop))))
     (g-main-loop-run main-loop)

   The (a-sync meeting) module provides the following procedures:

 -- Scheme Procedure: make-glib-meeting
     This procedure makes and returns a glib-meeting object.
     glib-meetings are objects on which a-sync or compose-a-sync blocks
     running on the default glib main loop can synchronize by one
     passing a datum to another.

     Strictly speaking this procedure can be called in any native OS
     thread, but since it carries out no synchronization of native
     threads the user would have to provide her own synchronization if
     called in other than the thread of the default glib main loop; so
     it is best if this procedure is called in the thread of that main
     loop.

 -- Scheme Procedure: glib-meeting? obj
     This procedure indicates whether 'obj' is a glib-meeting object
     constructed by make-glib-meeting.

 -- Scheme Procedure: glib-meeting-close meeting
     This closes a glib-meeting object.  It's purpose is to wake up any
     "pseudo-thread" (that is, any a-sync or compose-a-sync block)
     waiting in glib-meeting-send or glib-meeting-receive by causing
     either procedure to return with a 'stop-iteration value.

     Where that is not necessary (say, the receiver already knows how
     many items are to be sent), then this procedure does not need to be
     applied.  It is not needed in order to release resources.

 -- Scheme Procedure: glib-meeting-ready? meeting
     This indicates whether applying glib-meeting-send or
     glib-meeting-receive (as the case may be) to the glib-meeting
     object 'meeting' will return immediately: in other words, this
     procedure will return #t if another a-sync or compose-a-sync block
     is already waiting on the object or the glib-meeting object has
     been closed, otherwise #f.

 -- Scheme Procedure: glib-meeting-send await resume m0 [m1 ...] datum
     This sends a datum to a receiver via one or more glib-meeting
     objects 'm0 m1 ...'.  If no receiver is waiting for the datum, this
     procedure waits until a receiver calls glib-meeting-receive on one
     of the glib-meeting objects to request the datum.  If a receiver is
     already waiting, this procedure passes on the datum and returns
     immediately.

     This procedure is intended to be called within a waitable procedure
     invoked by a-sync (which supplies the 'await' and 'resume'
     arguments).

     Multiple senders may wait on a glib-meeting object to permit fan
     in.  The provided datum of each sender will be passed to a receiver
     (as and when a receiver becomes available) in the order in which
     this procedure was invoked.  In addition, this procedure has
     'select'-like behavior: multiple glib-meeting objects may be passed
     and this procedure will send to the first one which becomes
     available to receive the datum.

     Once a datum exchange has taken place, the glib-meeting object(s)
     can be reused for making another exchange (provided the
     glib-meeting objects have not been closed).

     This procedure must be called in the native OS thread in which the
     default glib main loop runs.  To have other native OS threads
     communicate with that loop, use await-glib-task-in-thread,
     await-glib-generator-in-thread, await-glib-task-in-thread-pool or
     await-glib-generator-in-thread-pool.

     This procedure always returns #f unless glib-meeting-close has been
     applied to a glib-meeting object, in which case 'stop-iteration is
     returned.  Note that if multiple glib-meeting objects are passed to
     this procedure and one of them is then closed, this procedure will
     return 'stop-iteration and any wait will be abandonned.  It is
     usually a bad idea to close a glib-meeting object on which this
     procedure is waiting where this procedure is selecting on more than
     one glib-meeting object.

 -- Scheme Procedure: glib-meeting-receive await resume m0 [m1 ...]
     This receives a datum from a sender via one or more glib-meeting
     objects 'm0 m1 ...'.  If no sender is waiting to pass the datum,
     this procedure waits until a sender calls glib-meeting-send on one
     of the glib-meeting objects to provide the datum.  If a sender is
     already waiting, this procedure returns immediately with the datum
     supplied.

     This procedure is intended to be called within a waitable procedure
     invoked by a-sync (which supplies the 'await' and 'resume'
     arguments).

     Multiple receivers may wait on a glib-meeting object to permit fan
     out.  The waiting receivers will be released (as and when a sender
     provides a datum) in the order in which this procedure was invoked.
     In addition, this procedure has 'select'-like behavior: multiple
     glib-meeting objects may be passed and this procedure will receive
     from the first one which sends a datum.

     Once a datum exchange has taken place, the glib-meeting object(s)
     can be reused for making another exchange (provided the
     glib-meeting objects have not been closed).

     This procedure must be called in the native OS thread in which the
     default glib main loop runs.  To have other native OS threads
     communicate with that loop, use await-glib-task-in-thread,
     await-glib-generator-in-thread, await-glib-task-in-thread-pool or
     await-glib-generator-in-thread-pool.

     This procedure always returns the datum value supplied by
     glib-meeting-send unless glib-meeting-close has been applied to a
     glib-meeting object, in which case 'stop-iteration is returned.
     Note that if multiple glib-meeting objects are passed to this
     procedure and one of them is then closed, this procedure will
     return 'stop-iteration and any wait will be abandonned.  It is
     usually a bad idea to close a glib-meeting object on which this
     procedure is waiting where this procedure is selecting on more than
     one glib-meeting object.



Tag Table:
Node: Top87
Node: overview1561
Node: coroutines4865
Node: event loop23257
Node: await ports69952
Node: thread pool96775
Node: monotonic time117601
Node: gnome glib119037
Node: compose147083
Node: meeting155071
Node: g-golf168564
Node: g-golf base169002
Node: g-golf await ports189593
Node: g-golf meeting210631

End Tag Table


Local Variables:
coding: utf-8
End:
