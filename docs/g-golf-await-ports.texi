@node g-golf await ports,g-golf meeting,g-golf base,g-golf

Most of the scheme files provided by this library are by default
compiled by this library to bytecode.  That is not the case with this
module, so as not to create a hard dependency on g-golf.

Including this module will automatically enable suspendable ports in
order to support the await-g-read-suspendable,
await-g-write-suspendable and await-g-getline procedures.  To disable
suspendable ports again, uninstall-suspendable-ports! can be called,
but this means that those procedures can no longer be used while
suspendable ports are disabled.  In addition, any port using those
procedures must be made non-blocking using fcntl as follows:

@example
(fcntl [port] F_SETFL (logior O_NONBLOCK
                      (fcntl [port] F_GETFL)))
@end example

The (a-sync g-golf await-ports) module provides the following procedures:

@deffn {Scheme Procedure} await-g-read-suspendable await resume port proc
'proc' is a procedure taking a single argument, to which the port will
be passed when it is invoked.  The purpose of 'proc' is to carry out
i/o operations on 'port' using the port's normal read procedures.
'port' must be a suspendable non-blocking port.  This procedure will
return when 'proc' returns, as if by blocking read operations, with
the value returned by 'proc'.  However, the glib main loop will not be
blocked by this procedure even if only individual characters or bytes
comprising part characters are available at any one time.  It is
intended to be called in a waitable procedure invoked by a-sync (which
supplies the 'await' and 'resume' arguments).  'proc' must not itself
explicitly apply 'await' and 'resume' as those are potentially in use
by the suspendable port while 'proc' is executing.

If an exceptional condition ('pri) is encountered by the
implementation, #f will be returned by this procedure and the read
operations to be performed by 'proc' will be abandonned; there is
however no guarantee that any exceptional condition that does arise
will be encountered by the implementation - the user procedure 'proc'
may get there first and deal with it, or it may not.  However
exceptional conditions are very rare, usually comprising only
out-of-band data on a TCP socket, or a pseudoterminal master in packet
mode seeing state change in a slave.  In the absence of an exceptional
condition, the value(s) returned by 'proc' will be returned.

This procedure must (like the a-sync procedure) be called in the same
thread as that in which the default glib main loop runs.

Exceptions (say, from 'proc' because of port or conversion errors)
will propagate out of this procedure in the first instance, and if not
caught locally will then propagate out of g-main-loop-run.

Unlike the await-* procedures in the (a-sync g-golf base) module, this
procedure will not call 'await' if the read operation(s) in 'proc' can
be effected immediately without waiting: instead, after reading this
procedure would return straight away without invoking the glib main
loop.

As an example of how to use await-g-read-suspendable, here is the
implementation of await-g-getline:

@example
(define (await-g-getline await resume port)
  (await-g-read-suspendable await resume port
			    (lambda (p)
			      (read-line p))))
@end example
@end deffn

@deffn {Scheme Procedure} await-g-getline await resume port
This procedure is provided mainly to retain compatibility with the
guile-a-sync library for guile-2.0, because it is trivial to implement
with await-g-read-suspendable (and is implemented by
await-g-read-suspendable).

It is intended to be called in a waitable procedure invoked by a-sync,
and reads a line of text from a non-blocking suspendable port and
returns it (without the terminating '\n' character).  See the
documentation on the await-g-read-suspendable procedure for further
particulars about this procedure.

Here is an example of the use of await-g-getline:
@example
(define main-loop (g-main-loop-new #f #f))
(a-sync (lambda (await resume)
          (display "Enter a line of text at the keyboard\n")
	  (let ((port (open "/dev/tty" O_RDONLY)))
	    (fcntl port F_SETFL (logior O_NONBLOCK
				(fcntl port F_GETFL)))
	    (simple-format #t
			   "The line was: ~A\n"
			   (await-g-getline await resume
					    port)))
	  (g-main-loop-quit main-loop)))
(g-main-loop-run main-loop)
@end example
@end deffn

@deffn {Scheme Procedure} await-g-getblock await resume port size
This procedure is provided mainly to retain compatibility with the
guile-a-sync library for guile-2.0, because an implementation is
trivial to implement with await-g-read-suspendable (and is implemented
by await-g-read-suspendable).

It is intended to be called in a waitable procedure invoked by a-sync,
and reads a block of data, such as a binary record, of size 'size'
from a non-blocking suspendable port 'port'.  This procedure will
return a pair, normally comprising as its car a bytevector of length
'size' containing the data, and as its cdr the number of bytes
received and placed in the bytevector (which will be the same as
'size' unless an end-of-file object was encountered part way through
receiving the data).  If an end-of-file object is encountered without
any bytes of data, a pair with eof-object as car and #f as cdr will be
returned.

See the documentation on the await-g-read-suspendable procedure for
further particulars about this procedure.
@end deffn

@deffn {Scheme Procedure} await-g-write-suspendable await resume port proc
'proc' is a procedure taking a single argument, to which the port will
be passed when it is invoked.  The purpose of 'proc' is to carry out
i/o operations on 'port' using the port's normal write procedures.
'port' must be a suspendable non-blocking port.  This procedure will
return when 'proc' returns, as if by blocking write operations, with
the value returned by 'proc'.  However, the glib main loop will not be
blocked by this procedure even if only individual characters or bytes
comprising part characters can be written at any one time.  It is
intended to be called in a waitable procedure invoked by a-sync (which
supplies the 'await' and 'resume' arguments).  'proc' must not itself
explicitly apply 'await' and 'resume' as those are potentially in use
by the suspendable port while 'proc' is executing.

If an exceptional condition ('pri) is encountered by the
implementation, #f will be returned by this procedure and the write
operations to be performed by 'proc' will be abandonned; there is
however no guarantee that any exceptional condition that does arise
will be encountered by the implementation - the user procedure 'proc'
may get there first and deal with it, or it may not.  However
exceptional conditions on write ports cannot normally occur.  In the
absence of an exceptional condition, the value(s) returned by 'proc'
will be returned.

This procedure must (like the a-sync procedure) be called in the same
thread as that in which the default glib main loop runs.

Exceptions (say, from 'proc' because of port or conversion errors)
will propagate out of this procedure in the first instance, and if not
caught locally will then propagate out of g-main-loop-run.

Unlike the await-* procedures in the (a-sync g-golf base) module, this
procedure will not call 'await' if the write operation(s) in 'proc'
can be effected immediately without waiting: instead, after writing
this procedure would return straight away without invoking the glib
main loop.

As an example of how to use await-g-write-suspendable, here is the
implementation of await-g-put-string:

@example
(define (await-g-put-string await resume port text)
  (await-g-write-suspendable await resume port
			     (lambda (p)
			       (put-string p text)
			       ;; enforce a flush when the current
			       ;; write-waiter is still in operation
			       (force-output p))))
@end example
@end deffn

@deffn {Scheme Procedure} await-g-put-bytevector await resume port bv
This procedure is provided mainly to retain compatibility with the
guile-a-sync library for guile-2.0, because it is trivial to implement
with await-g-write-suspendable (and is implemented by
await-g-write-suspendable).

It is intended to be called in a waitable procedure invoked by a-sync,
and will write a bytevector to the port.

See the documentation on the await-g-write-suspendable procedure for
further particulars about this procedure.

As mentioned in relation to the await-g-write-suspendable procedure,
write exceptions will propagate out of this procedure in the first
instance, and if not caught locally (say by placing a catch block
immediately around this procedure) will then propagate out of
g-main-loop-run.  So one way of testing for EPIPE is as follows:
@example
(define main-loop (g-main-loop-new #f #f))
(a-sync (lambda (await resume)
	  (catch 'system-error
		 (lambda ()
		   (await-g-put-bytevector await resume port bv))
		 (lambda args
		   (if (= (system-error-errno args) EPIPE)
		       (begin
			 ... do something to cater for EPIPE ...)
		       (begin
			 ;; possibly rethrow the exception
			 (apply throw args)))))
	  (g-main-loop-quit main-loop)))
(g-main-loop-run main-loop)
@end example
@end deffn

@deffn {Scheme Procedure} await-g-put-string await resume port text
This procedure is provided mainly to retain compatibility with the
guile-a-sync library for guile-2.0, because it is trivial to implement
with await-g-write-suspendable (and is implemented by
await-g-write-suspendable).

It is intended to be called in a waitable procedure invoked by a-sync,
and will write a string to the port.

If CR-LF line endings are to be written when outputting the string,
the '\r' character (as well as the '\n' character) must be embedded in
the string.

See the documentation on the await-g-write-suspendable procedure for
further particulars about this procedure.

As mentioned in relation to the await-g-write-suspendable procedure,
write exceptions will propagate out of this procedure in the first
instance, and if not caught locally (say by placing a catch block
immediately around this procedure) will then propagate out of
g-main-loop-run.  So one way of testing for EPIPE is as follows:
@example
(define main-loop (g-main-loop-new #f #f))
(a-sync (lambda (await resume)
	  (catch 'system-error
		 (lambda ()
		   (await-g-put-string await resume port "test"))
		 (lambda args
		   (if (= (system-error-errno args) EPIPE)
		       (begin
			 ... do something to cater for EPIPE ...)
		       (begin
			 ;; possibly rethrow the exception
			 (apply throw args)))))
	  (g-main-loop-quit main-loop)))
(g-main-loop-run main-loop)
@end example
@end deffn
